	ld	a,0
=
	xor	a

	ld	hl,%0	;const
	ld	a,l
	ld	(%1),a
	ld	hl,%2
=
	ld	a,%eval(%0 256 %%)
	ld	(%1),a
	ld	hl,%2

	jp	%0	;%5
.%0
=
.%0

	ex	de,hl
	ld	l,8
	call	l_asr_u
=
	ld	l,h
	ld	h,0

	ex	de,hl
	ld	l,8
	call	l_asr
=
	ld	a,h
	call	l_sxt

	ex	de,hl
	ld	l,0
	call	l_asr%1
=

	ex	de,hl
	ld	l,8
	call	l_asl
=
	ld	h,l
	ld	l,0

	ex	de,hl
	ld	l,0
	call	l_asl
=

	ex	de,hl
	ld	l,1
	call	l_asl
=
	add	hl,hl

	ld	hl,0	;const
	add	hl,sp
	push	hl
	call	l_gint	;%9
	inc	hl
	pop	de
	call	l_pint
=
	pop	hl
	inc	hl
	push	hl

	ld	hl,0	;const
	add	hl,sp
	call	l_gint	;%9
	inc	hl
	pop	bc
	push	hl
=
	pop	hl
	inc	hl
	push	hl

	ld	hl,0	;const
	add	hl,sp
	call	l_gint	;%9
	ld	de,%1
	add	hl,de
	pop	bc
	push	hl
=
	pop	hl
	ld	de,%1	;const
	add	hl,de
	push	hl

	ld	hl,0	;const
	add	hl,sp
	call	l_gint	;%9
	dec	hl
	pop	bc
	push	hl
=
	pop	hl
	dec	hl
	push	hl

	ld	hl,0	;const
	add	hl,sp
	push	hl
	call	l_gint	;%9
	dec	hl
	pop	de
	call	l_pint
=
	pop	hl
	dec	hl
	push	hl

%notcpu 8085
	ld	hl,2	;const
	add	hl,sp
	push	hl
	call	l_gint	;%9
	inc	hl
	pop	de
	call	l_pint
=
	pop	de
	pop	hl
	inc	hl
	push	hl
	push	de

	ld	hl,2	;const
	add	hl,sp
	call	l_gint	;%9
	inc	hl
	pop	de
	pop	bc
	push	hl
	push	de
=
	pop	de
	pop	hl
	inc	hl
	push	hl
	pop	de

	ld	hl,0	;const
	add	hl,sp
	call	l_gint	;%9
	ld	de,%1
	add	hl,de
	pop	de
	pop	bc
	push	hl
	push	de
=
	pop	de
	pop	hl
	ld	bc,%1
	add	hl,bc
	push	hl
	push	de

	ld	hl,2	;const
	add	hl,sp
	call	l_gint	;%9
	dec	hl
	pop	de
	pop	bc
	push	hl
	push	de
=
	pop	de
	pop	hl
	dec	hl
	push	hl
	push	de

%notcpu 8085
	ld	hl,2	;const
	add	hl,sp
	push	hl
	call	l_gint	;%9
	dec	hl
	pop	de
	call	l_pint
=
	pop	de
	pop	hl
	dec	hl
	push	hl
	push	de

	ld	hl,2	;const
	add	hl,sp
	call	l_gint	;%9
=
	pop	bc
	pop	hl
	push	hl
	push	bc

	call	dload
	call	dpush
=
	call	dldpsh

	call	l_f64_load
	call	l_f64_dpush
=
	call	l_f64_dldpsh

	jp	nz,%1	;%3
	jp	%2	;%4
.%1
=
	jp	z,%2	;%4
.%1

	jp	z,%1	;%3
	jp	%2	;%4
.%1
=
	jp	nz,%2	;%4
.%1

	jp	nz,%1	;%3
	jp	z,%2	;%4
.%1
=
	jp	z,%4	;%4
.%1

	jp	z,%1	;%3
	jp	nz,%2	;%4
.%1
=
	jp	nz,%2	;%4
.%1

	jp	z,%1	;%3
	call	%2
.%1
=
	call	nz,%2
.%1

	jp	nz,%1	;%3
	call	%2
.%1
=
	call	z,%2
.%1

	jp	z,%1	;%3
	jp	%2	;%4
.%1
=
	jp	nz,%2	;%4
.%1

	ld	hl,%1	;const
	ex	de,hl
	ld	hl,%2	;const
=
	ld	de,%1
	ld	hl,%2	;const

	ld	(%1),%2
	ld	%2,(%1)
=
	ld	(%1),%2

	jp	z,%1	;%3
	ret
.%1
=
	ret	nz
.%1

	jp	nz,%1	;%3
	ret
.%1
=
	ret	z
.%1

%notcpu gbz80
	push	hl
	ld	hl,%1	;const
	pop	de
=
	ld	de,%1	;const
	ex	de,hl

	ld	hl,0	;const
	add	hl,sp
	call	l_gint	;%9
=
	pop	hl
	push	hl

	ld	hl,%1	;const
	add	hl,sp
	ld	de,%2
	add	hl,de
=
	ld	hl,%eval(%1 %2 +)	;const
	add	hl,sp

	ld	hl,%1	;const
	add	hl,sp
	inc	hl
=
	ld	hl,%eval(%1 1 +)	;const
	add	hl,sp

	ld	de,0
	ex	de,hl
	call	l_eq
	jp	c,%1	;%3
=
	ld	a,h
	or	l
	jp	z,%1	;%3

;;; Fixes up a bug in these rules
	ld	(hl),%1
	ld	l,(hl)
	ld	h,0
	inc	de
	ld	a,h
	ld	(de),a
=
	ld	(hl),%1
	inc	hl
	ld	(hl),0
	ld	hl,%1

;;; This rule causes above bug, can't stop it from firing though
	ld	de,%1	;const
	ex	de,hl
	ld	a,l
	ld	(de),a
=
	ld	(hl),%eval(%1 256 %%)
	ld	l,(hl)
	ld	h,0

	push	de
	push	hl
	ld	hl,1	;const
	ld	de,0
	call	l_long_add
=
	call	l_inclong

	push	de
	push	hl
	ld	hl,2	;const
	ld	de,0
	call	l_long_add
=
	call	l_inclong
	call	l_inclong

	push	de
	push	hl
	ld	hl,65535	;const
	ld	de,65535
	call	l_long_add
=
	call	l_declong

	dec	hl
	ld	hl,%1	;const
=
	ld	hl,%1	;const

	inc	hl
	ld	hl,%1	;const
=
	ld	hl,%1	;const

	add	hl,%1
	ld	hl,%2	;const
=
	ld	hl,%2	;const

	push	bc
	pop	bc
	push	hl
=
	push	hl

	push	bc
	ld	hl,%1
	pop	bc
=
	ld	hl,%1

	pop	hl
	push	hl
	pop	bc
	ret
=
	pop	hl
	ret

	ld	a,h
	or	l
	jp	nz,%1	;%3
	ld	hl,0	;const
	pop	bc
	ret
=
	ld	a,h
	or	l
	jp	nz,%1	;%3
	pop	bc
	ret

	ld	hl,_%1
	ld	bc,%2
	add	hl,bc
=
	ld	hl,_%1+%2

	ld	hl,_%1
	ld	bc,-%2
	add	hl,bc
=
	ld	hl,_%1-%2
	add	hl,bc

	ld	hl,_%1+%2
	inc	hl
=
	ld	hl,_%1+%eval(%2 1 +)

	ld	hl,_%1
	inc	hl
=
	ld	hl,_%1+1

%notcpu gbz80
	ld	hl,_%1
	call	l_gint	;%9
=
	ld	hl,(_%1)

%notcpu gbz80
	ld	hl,_%1
	call	l_glong
=
	ld	hl,(_%1+2)
	ex	de,hl
	ld	hl,(_%1)

%notcpu gbz80
	ld	hl,_%1
	ld	l,(hl)
	ld	h,0
=
	ld	hl,(_%1)
	ld	h,0

	ld	hl,%1	;const
	jp	%2	;%3
	ld	hl,%1	;const
=
	ld	hl,%1	;const
	jp	%2	;%3

	pop	bc
	pop	hl
	push	hl
	push	bc
	pop	bc
	pop	bc
	ret
=
	pop	bc
	pop	hl
	ret

	pop	bc
	push	hl
	pop	hl
	push	hl
=
	pop	bc
	push	hl

	pop	hl
	push	hl
	ld	bc,%1
	add	hl,bc
	pop	bc
	push	hl
=
	pop	hl
	ld	bc,%1
	add	hl,bc
	push	hl

	push	bc
	push	bc
	ld	hl,%1
	pop	de
	pop	bc
	push	hl
	push	de
=
	ld	hl,%1
	push	hl
	push	bc

	ld	hl,_%1
	ld	a,(hl)
	cp	%3
=
	ld	a,(_%1)
	cp	%3

	ld	hl,_%1
	ld	a,(hl)
	and	a
=
	ld	a,(_%1)
	and	a

	ld	de,%1
	pop	de
=
	pop	de

	exx
	ld	hl,%1	;const
	add	hl,sp
	ld	sp,hl
	exx
	ld	hl,%2	;const
	add	hl,sp
	ld	sp,hl
=
	exx
	ld	hl,%eval(%1 %2 +)	;const
	add	hl,sp
	ld	sp,hl
	exx

	ld	de,%1
	pop	de
=
	pop	de

	call	l_int2long_s
	pop	de
=
	pop	de

	jp	i_%1	;%3
	jp	i_%2	;%4
=
	jp	i_%1	;%3

%check 0 <= %2 <= 65535
	ld	hl,%1	;const
	add	hl,sp
	ld	bc,%2
	add	hl,bc
=
	ld	hl,%eval(%1 %2 +)	;const
	add	hl,sp

	call	l_inclong
	ld	hl,%1
=
	ld	hl,%1

	call	l_declong
	ld	hl,%1
=
	ld	hl,%1

	call	exit
	pop	%1
=
	call	exit

	call	exit
	ld	hl,%1	;const
	add	hl,sp
	ld	sp,hl
=
	call	exit

	push	hl
	pop	bc
	ret
=
	ret

	ld	de,1	;const
	ex	de,hl
	call	l_eq
	jp	nc,%1	;%3
=
	dec	hl
	ld	a,h
	or	l
	jp	nz,%1	;%3

	ld	de,1	;const
	ex	de,hl
	call	l_eq
	jp	c,%1	;%3
=
	dec	hl
	ld	a,h
	or	l
	jp	z,%1	;%3

	ld	de,65535	;const
	ex	de,hl
	call	l_ne
	jp	nc,%1	;%3
=
	inc	hl
	ld	a,h
	or	l
	jp	z,%1	;%3

	push	de
	ld	hl,65535	;const
	pop	de
	call	l_eq
	jp	nc,%1	;%3
=
	inc	de
	ld	a,d
	or	e
	jp	nz,%1	;%3

	push	de
	ld	hl,65535	;const
	pop	de
	call	l_eq
	jp	c,%1	;%3
=
	inc	de
	ld	a,d
	or	e
	jp	z,%1	;%3

	push	de
	ld	hl,1	;const
	pop	de
	call	l_eq
	jp	c,%1	;%3
=
	dec	de
	ld	a,d
	or	e
	jp	z,%1	;%3

	push	de
	ld	hl,1	;const
	pop	de
	call	l_eq
	jp	nc,%1	;%3
=
	dec	de
	ld	a,d
	or	e
	jp	nz,%1	;%3

	ld	de,65535	;const
	ex	de,hl
	call	l_eq
	jp	nc,%1	;%3
=
	inc	hl
	ld	a,h
	or	l
	jp	nz,%1	;%3

	ld	de,65535	;const
	ex	de,hl
	call	l_eq
	jp	c,%1	;%3
=
	inc	hl
	ld	a,h
	or	l
	jp	z,%1	;%3

	ld	hl,0	;const
	ld	de,0
	call	l_long_as%1
=
	pop	bc
	pop	bc

	ld	hl,%1	;const
	ld	de,%2
	call	l_long_as%3
=
	ld	l,%eval(%1 256 %%)
	call	l_long_as%3

	push	hl
	call	l_glong
	push	de
	push	hl
	pop	bc
	pop	bc
	pop	bc
	call	l_plong
=

	ld	hl,%1	;const
	add	hl,sp
	ld	hl,%2
=
	ld	hl,%2

	ld	hl,%1	;const
	call	l_as%2
=
	ld	l,%eval(%1 256 %%)
	call	l_as%2

	ld	de,%1	;const
	ex	de,hl
	call	l_as%2
=
	ex	de,hl
	ld	l,%eval(%1 256 %%)
	call	l_as%2

	ex	de,hl
	pop	hl
	push	hl
	ex	de,hl
=
	pop	de
	push	de

	pop	hl
	push	hl
	ex	de,hl
=
	pop	de
	push	de

.%1
	jp	%3	;%4
.%2
	jp	%1	;%5
.%3
=
.%1
.%2
.%3

	pop	de
	pop	bc
	push	hl
	push	de
	pop	bc
	pop	hl
	push	hl
	push	bc
=
	pop	de
	pop	bc
	push	hl
	push	de

	ld	a,h
	or	l
	jp	nz,%1	;%3
	ld	hl,1	;const
=
	ld	a,h
	or	l
	jp	nz,%1	;%3
	inc	hl

	pop	hl
	push	hl
	ld	a,l
	cp	%2
	jp	z,%3	;%4
	pop	hl
	push	hl
	ld	a,l
=
	pop	hl
	push	hl
	ld	a,l
	cp	%2
	jp	z,%3	;%4

	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
	cp	%2
	jp	z,%3	;%4
	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
=
	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
	cp	%2
	jp	z,%3	;%4

	push	de
	push	hl
	ld	l,%1
	call	l_long_asl
=
	ld	a,%1
	call	l_long_aslo

	push	de
	push	hl
	ld	l,%1
	call	l_long_asr%2
=
	ld	c,%1
	call	l_long_asr%2o

%check 0 <= %1 <= 65535
	ld	l,(hl)
	ld	h,0
	ld	de,%1
	ex	de,hl
=
	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const

%notcpu 8085
	call	l_gint	;%9
	push	hl
	ld	hl,%1
=
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	push	de
	ld	hl,%1

%notcpu gbz80
	ld	hl,_%1
	ld	de,%2
	ex	de,hl
	call	l_pint
=
	ld	hl,%2
	ld	(_%1),hl

	pop	bc
	push	hl
	pop	bc
	push	hl
=
	pop	bc
	push	hl

	ld	hl,%1	;const
	add	hl,sp
	push	hl
	call	l_gint	;%9
	pop	de
	call	l_pint
=
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;%9

	ld	hl,%1	;const
	add	hl,sp
	push	hl
	call	l_glong
	pop	bc
	call	l_plong
=
	ld	hl,%1	;const
	add	hl,sp
	call	l_glong

	push	de
	push	hl
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;%9
	call	l_int2long_s
	call	l_long_asl
=
	push	hl
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	ld	a,(hl)
	pop	hl
	call	l_long_aslo

	push	de
	push	hl
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;%9
	ld	de,0
	call	l_long_asl
=
	push	hl
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	ld	a,(hl)
	pop	hl
	call	l_long_aslo

%notcpu gbz80
	ld	a,16
	call	l_long_aslo
=
	ex	de,hl
	ld	hl,0	;const

%notcpu gbz80
	push	hl
	ld	hl,(_%1
	pop	de
=
	ex	de,hl
	ld	hl,(_%1

	pop	hl
	push	hl
	ex	de,hl
=
	pop	de
	push	de

	ld	hl,0	;const
	add	hl,sp
	ld	a,(hl)
	add	a,%1
	ld	(hl),a
	ld	l,a
	ld	h,0
=
	pop	hl
	ld	a,l
	add	a,%1
	ld	l,a
	push	hl
	ld	h,0

	push	de
	pop	bc
	pop	hl
	push	hl
	push	bc
=
	pop	hl
	push	hl
	push	de

	push	de
	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
	pop	de
=
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	ld	a,(hl)

	ld	hl,%1
	push	hl
	ld	hl,%1
=
	ld	hl,%1
	push	hl

	ld	hl,%1
	add	hl,sp
	push	hl
	ld	hl,%1
	add	hl,sp
=
	ld	hl,%1
	add	hl,sp
	push	hl
	dec	hl
	dec	hl

	ld	hl,0	;const
	jp	%2	;%4
.%1
	ld	hl,1	;const
.%2
	ld	a,h
	or	l
	jp	z,%3	;%5
=
	ld	hl,0	;const
	jp	%3	;%5
.%1
	ld	hl,1	;const
.%2
	ld	a,h
	or	l
	jp	z,%3	;%4

	ld	hl,(%1)
	ld	h,0
	dec	hl
	ld	a,l
	ld	(%1),a
	inc	hl
=
	ld	hl,%1
	ld	a,(hl)
	dec	(hl)
	ld	l,a
	ld	h,0

	ld	hl,(%1)
	ld	h,0
	inc	hl
	ld	a,l
	ld	(%1),a
	dec	hl
=
	ld	hl,%1
	ld	a,(hl)
	inc	(hl)
	ld	l,a
	ld	h,0

	ld	l,a
	ld	h,0
	ld	hl,%1
=
	ld	hl,%1

	ld	l,(hl)
	ld	h,0
	ld	hl,%1
=
	ld	hl,%1

	ld	hl,%1
	%2	(hl)
	ld	hl,(%1)
	ld	h,0
=
	ld	hl,%1
	%2	(hl)
	ld	l,(hl)
	ld	h,0

	ld	l,a
	ld	h,0
.%1
	ld	hl,%2
=
.%1
	ld	hl,%2

	ld	a,l
	ld	(de),a
	ld	a,h
	or	l
	jp	z,%1	;%3
=
	ld	a,l
	ld	(de),a
	and	a
	jp	z,%1	;%3

	ld	a,l
	ld	(de),a
	ld	a,h
	or	l
	jp	nz,%1	;%3
=
	ld	a,l
	ld	(de),a
	and	a
	jp	nz,%1	;%3

	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	call	l_eq
	jp	nc,%2	;%4
	ld	hl,%3
=
	ld	a,(hl)
	cp	%eval(%1 256 %%)
	jp	nz,%2	;%4
	ld	hl,%3

	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	call	l_eq
	jp	c,%2	;%4
	ld	hl,%3
=
	ld	a,(hl)
	cp	%eval(%1 256 %%)
	jp	z,%2	;%4
	ld	hl,%3

	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	call	l_ne
	jp	c,%2	;%4
	ld	hl,%3
=
	ld	a,(hl)
	cp	%eval(%1 256 %%)
	jp	nz,%2	;%4
	ld	hl,%3

	ld	hl,(%1)
	ld	h,0
	ld	a,h
	or	l
	jp	nz,%2	;%4
	ld	hl,%3
=
	ld	a,(%1)
	and	a
	jp	nz,%2	;%4
	ld	hl,%3

%notcpu gbz80
	push	hl
	ld	hl,(%1)
	ld	h,0
	pop	de
=
	ex	de,hl
	ld	hl,(%1)
	ld	h,0

	pop	hl
	push	hl
	push	hl
	pop	bc
	pop	hl
	push	hl
	push	bc
=
	pop	hl
	push	hl
	push	hl

	ld	de,0	;const
	ex	de,hl
	call	l_eq
	pop	bc
	push	hl
	ld	a,h
	or	l
	jp	z,%1	;%4
=
	pop	bc
	push	hl
	ld	a,h
	or	l
	jp	nz,%1	;%4

%notcpu gbz80
	push	hl
	pop	bc
	pop	hl
	push	hl
	push	bc
	pop	de
=
	ex	de,hl
	pop	hl
	push	hl

	push	hl
	ld	(%1),hl
	pop	hl
=
	ld	(%1),hl

%notcpu gbz80
	ld	l,(hl)
	ld	h,0
	ex	de,hl
	ld	hl,%1
=
	ld	e,(hl)
	ld	d,0
	ld	hl,%1

%notcpu gbz80
	ld	hl,_%1
	ex	de,hl
	pop	hl
	push	hl
	call	l_pint
=
	pop	hl
	ld	(_%1),hl
	push	hl

	push	hl
	pop	hl
	ret
=
	ret

	push	de
	push	hl
	ld	hl,0	;const
	ld	de,0
	call	l_long_eq
	jp	c,%1	;%4
=
	ld	a,h
	or	l
	or	e
	or	d
	jp	z,%1	;%4

	pop	bc
	push	hl
	ld	a,h
	or	l
	jp	nz,%1	;%4
	pop	bc
	ret
.%1
=
	pop	bc
	ld	a,h
	or	l
	ret	z
	push	hl
.%1

; Rules for optimizing the tail of if statements (valid for && and || )
; These are only valid if we don't try to set a variable to the logical result, if
; we do then it's a tad pointless and you'll suffer!!! <cackle?
=
;

	ld	de,%1	;const
	ld	(hl),e
	inc	hl
	ld	(hl),d
	jp	%2	;EOS
=
	ld	(hl),%eval(%1 256 %%)
	inc	hl
	ld	(hl),%eval(%1 256 /)
	jp	%2	;EOS

	ld	hl,0	;const
	jr	%1
.%2
	ld	hl,1	;const
.%1
	ld	a,h
	or	l
	jp	z,%3	;%4
=
	jp	%3	;%4
.%2

	ld	hl,1	;const
	jr	%1
.%2
	ld	hl,0	;const
.%1
	ld	a,h
	or	l
	jp	z,%3	;%4
=
	jp	%1_%2
.%2
	jp	%3	;%4
.%1_%2

	jp	n%0,%1	;%4
	jr	%2
.%1
	jp	%3	;%5
.%2
=
	jr	%0,%2
.%1
	jp	%3	;%5
.%2

	ld	a,h
	or	l
	jp	nz,%1	;%4
	ld	hl,0	;const
	jp	%2	;%5
.%1
=
	ld	a,h
	or	l
	jp	z,%2	;%5
.%1

	jp	nc,%1	;%4
	jp	%2	;%5
.%1
=
	jp	c,%2	;%5
.%1

	jp	c,%1	;%4
	jp	%2	;%5
.%1
=
	jp	nc,%2	;%5
.%1

	jr	c,%1
.%2
	jp	%3	;%6
.%1
	jp	%4	;%7
.%3
	jp	%5	;%8
.%4
=
	jr	c,%4
.%2
.%3
	jp	%5	;%8
.%1
.%4

	jr	z,%1
	jp	nc,%2	;%6
.%1
	jr	%3
.%2
	jp	%5	;%7
.%3
=
	jr	z,%3
	jr	c,%3
.%2
	jp	%5	;%7
.%3

	push	de
	ld	hl,%1
	pop	de
=
	ld	hl,%1

	ld	hl,%1
	%2	(hl)
	ld	a,(%1)
=
	ld	hl,%1
	%2	(hl)
	ld	a,(hl)

	push	de
	pop	hl
	push	hl
=
	push	de
	ld	l,e
	ld	h,d

	pop	bc
	pop	hl
	push	hl
	push	bc
	ld	de,%1	;const
	ex	de,hl
=
	pop	bc
	pop	de
	push	de
	push	bc
	ld	hl,%1	;const

%notcpu 8085
%notcpu gbz80
	push	hl
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;%9
	pop	de
=
	ex	de,hl
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	call	l_gint	;%9

%notcpu 8080
%notcpu 8085
%notcpu gbz80
	ld	hl,%1
	ex	de,hl
	ld	hl,%2
=
	ld	de,%1
	ld	hl,%2

	push	%1
	pop	%1
	push	%1
=
	push	%1

	pop	bc
	pop	hl
	push	hl
	push	bc
	push	hl
	pop	bc
	pop	hl
	push	hl
	push	bc
	push	hl
=
	pop	de
	pop	hl
	push	hl
	push	de
	push	hl
	push	de

	ld	hl,4	;const
	add	hl,sp
	push	hl
	ld	hl,6	;const
	add	hl,sp
=
	ld	hl,4	;const
	add	hl,sp
	push	hl

	ld	hl,%1	;const
	ld	a,l
	ld	l,h
	ld	h,a
=
	ld	hl,%eval(%1 256 / %1 256 %% 256 * +)

	ld	hl,0	;const
	add	hl,sp
	push	hl
	call	l_gint	;%9
	ld	bc,%1
	add	hl,bc
	pop	de
	call	l_pint
=
	pop	hl
	ld	bc,%1
	add	hl,bc
	push	hl

	call	exit
	ret
=
	jp	exit

	ld	l,(hl)
	ld	h,0
.%1
	ld	hl,%2
=
.%1
	ld	hl,%2

	ld	(hl),%1
	ld	l,(hl)
	ld	h,0
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
	ld	a,%1
	ld	(hl),a
	pop	de
	ld	(de),a
	ld	hl,%2

%check 0 <= %1 <= 255
	pop	hl
	inc	hl
	push	hl
	dec	hl
	ld	(hl),%1
=
	pop	hl
	ld	(hl),%1
	inc	hl
	push	hl
	dec	hl

	push	hl
	pop	hl
	%1c	hl
	push	hl
=
	%1c	hl
	push	hl

	ld	hl,%1
	exx
	ld	hl,%2
	add	hl,sp
	ld	sp,hl
	exx
	ret
=
	ld	hl,%2
	add	hl,sp
	ld	sp,hl
	ld	hl,%1
	ret

	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	call	l_and
=
	ld	a,(hl)
	and	%eval(%1 256 %%)
	ld	l,a
	ld	h,0

	ld	l,a
	ld	h,0
	ld	h,l
	ld	l,0
=
	ld	h,a
	ld	l,0

	ld	hl,0	;const
	push	hl
	ld	hl,1	;const
=
	ld	hl,0	;const
	push	hl
	inc	hl

	ld	hl,1	;const
	push	hl
	ld	hl,0	;const
=
	ld	hl,1	;const
	push	hl
	dec	hl

	push	hl
	ld	a,h
	or	l
	jp	%1	;%2
	pop	hl
	push	hl
=
	push	hl
	ld	a,h
	or	l
	jp	%1	;%2

%notcpu gbz80
	push	hl
	ld	hl,%1
	pop	de
=
	ex	de,hl
	ld	hl,%1

	push	bc
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;%9
	pop	bc
	push	hl
=
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	call	l_gint	;%9
	push	hl

	exx
	ld	hl,%1	;const
	add	hl,sp
	ld	sp,hl
	exx
	ld	hl,%2
=
	ld	hl,%1	;const
	add	hl,sp
	ld	sp,hl
	ld	hl,%2

	push	af
	ld	hl,%1
	pop	af
=
	ld	hl,%1

	ld	l,(hl)
	ld	h,0
	ld	a,l
	ld	l,h
	ld	h,a
=
	ld	h,(hl)
	ld	l,0

	pop	bc
	push	hl
	ld	a,h
	or	l
	jp	nz,%1	;%2
	pop	bc
	ret
=
	pop	bc
	ld	a,h
	or	l
	ret	z
	push	hl
	jp	%1	;%2

	ld	h,0
	%1c	l
	ld	a,h
	or	l
	jp	%2	;%5
=
	ld	h,0
	%1c	l
	jp	%2	;%5

	ld	a,h
	or	l
	jp	nz,%1	;%5
	ld	hl,0	;const
=
	ld	a,h
	or	l
	jp	nz,%1	;%5

	ld	l,e
	ld	h,d
	ld	bc,%1
	add	hl,bc
=
	ld	hl,%1
	add	hl,de

	ld	hl,(%1)
	ld	h,0
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
	ld	a,(%1)
	ld	(de),a
	ld	hl,%2

	jp	z,%1	;%7
	jr	%2
.%1
	jp	%3	;%8
.%2
=
	jr	nz,%2
.%1
	jp	%3	;%8
.%2

	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;%9
	ld	a,(hl)
	cp	%2
	jp	%3	;%8
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;%9
	ld	a,(hl)
	cp	%4
=
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;%9
	ld	a,(hl)
	cp	%2
	jp	%3	;%8
	cp	%4

	jp	nc,%1	;%7
	ld	hl,1	;const
	jr	%2
.%1
	ld	hl,0	;const
.%2
	ld	a,h
	or	l
	jp	nz,%3	;%8
	ld	hl,%4
=
	jp	c,%3	;%8
.%1
	jp	%1_%2
.%2
	ld	a,h
	or	l
	jp	nz,%3	;%8
.%1_%2
	ld	hl,%4

	jp	%1,%2	;%5
.%3
	jp	%4	;%6
.%2
=
	jr	%1,%2
.%3
	jp	%4	;%6
.%2

; These next few rules deal with optimizing for testing a
; signed int for being < 0, we end up with saving of 7 bytes
=
;

%notcpu 8080
%notcpu 8085
	ld	hl,0	;const
	call	l_lt
	jp	nc,%1	;%3
	ld	hl,%2
=
	bit	7,d
	jp	z,%1	;%3
	ld	hl,%2

%notcpu 8080
%notcpu 8085
	ld	hl,0	;const
	call	l_lt
	jp	c,%1	;%3
	ld	hl,%2
=
	bit	7,d
	jp	nz,%1	;%3
	ld	hl,%2

%notcpu 8080
%notcpu 8085
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	bit	7,d
=
	inc	hl
	ld	a,(hl)
	bit	7,a

	ld	a,(hl)
	bit	7,a
	jp	nz,%1	;%3
=
	ld	a,(hl)
	rlca
	jp	c,%1	;%3

	ld	a,(hl)
	bit	7,a
	jp	z,%1	;%3
=
	ld	a,(hl)
	rlca
	jp	nc,%1	;%3

	ld	hl,%1	;const
	push	hl
	pop	bc
	pop	hl
	push	hl
	push	bc
	add	hl,hl
	pop	de
	add	hl,de
=
	pop	hl
	push	hl
	add	hl,hl
	ld	de,%1
	add	hl,de

	ld	hl,%1
	push	hl
	pop	bc
	pop	hl
	push	hl
	push	bc
	add	hl,hl
	pop	de
	add	hl,de
=
	pop	hl
	push	hl
	add	hl,hl
	ld	de,%1
	add	hl,de

	ld	hl,%1	;const
	push	hl
	pop	bc
	pop	hl
	push	hl
	push	bc
	push	hl
=
	pop	hl
	push	hl
	ld	de,%1
	push	de
	push	hl

	ld	hl,%1
	ld	de,%2
	ex	de,hl
	call	l_eq
=
	ld	hl,%1
	ld	de,%2
	call	l_eq

	ld	hl,%1
	ld	de,0	;const
	call	l_eq
	jp	c,%4	;%5
	ld	hl,%3
=
	ld	hl,%1
	ld	a,h
	or	l
	jp	z,%4	;%5
	ld	hl,%3

	ex	de,hl
	ld	de,%1
	ex	de,hl
=
	ld	hl,%1

	ld	hl,%1	;const
	add	hl,sp
	pop	de
	add	hl,de
	dec	hl
=
	ld	hl,%eval(%1 1 -)	;const
	add	hl,sp
	pop	de
	add	hl,de

	pop	bc
	push	hl
	%1c	hl
	%1c	hl
	pop	bc
	push	hl
=
	%1c	hl
	%1c	hl
	pop	bc
	push	hl

	ld	hl,%1
	inc	(hl)
	ld	l,(hl)
	ld	h,0
	dec	l
	ld	a,(%1)
=
	ld	hl,%1
	ld	a,(hl)
	inc	(hl)

	pop	hl
	push	hl
	pop	bc
	pop	bc
	ret
=
	pop	hl
	pop	bc
	ret

	ld	l,(hl)
	ld	h,0
	%1c	hl
	ld	hl,%2
=
	ld	hl,%2

	ld	hl,0	;const
	add	hl,sp
	add	a,%1
	ld	(hl),a
	ld	l,a
	ld	h,0
=
	pop	hl
	ld	a,l
	add	a,%1
	ld	l,a
	push	hl
	ld	h,0

	ld	hl,%1
	add	hl,sp
	push	hl
	ld	hl,%2
	call	dload
	pop	hl
	call	dstore
=
	ld	hl,%2
	call	dload
	ld	hl,%1
	add	hl,sp
	call	dstore

	ld	e,(hl)
	ld	d,0
	ld	hl,(%1)
	ld	h,0
	call	l_eq
	jp	nc,%2	;%5
=
	ld	a,(%1)
	cp	(hl)
	jp	nz,%2	;%5

	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	l,8
	call	l_asr_u
=
	inc	hl
	ld	l,(hl)
	ld	h,0

%notcpu gbz80
	push	hl
	ld	hl,%1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	pop	de
=
	ex	de,hl
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0

	jp	nc,%1	;%5
	call	%2
.%1
=
	call	c,%2
.%1

	jp	c,%1	;%5
	call	%2
.%1
=
	call	nc,%2
.%1

	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	call	l_eq
	ld	hl,0	;const
	rl	l
=
	ld	a,(hl)
	cp	%eval(%1 256 %%)
	ld	hl,0	;const
	jr	nz,ASMPC+3
	inc	hl

	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	call	l_eq
	ld	hl,%2
	jp	c,%3	;%5
	ld	hl,%4
=
	ld	a,(hl)
	cp	%eval(%1 256 %%)
	ld	hl,%2
	jp	z,%3	;%5
	ld	hl,%4

%title Optimise int <= 0
	jr	c,ASMPC+6
	or	l
	jr	nz,ASMPC+3
	scf
	jp	c,%1	;%2
=
	jp	c,%1
	or	l
	jp	z,%1

%title Optimise long <= 0
	jr	c,ASMPC+8
	or	e
	or	h
	or	l
	jr	nz,ASMPC+3
	scf
	jp	c,%1	;%2
=
	jp	c,%1
	or	e
	or	h
	or	l
	jp	z,%1

	jr	z,ASMPC+3
	scf
	call	c,%2
=
	call	nz,%2

	jr	nz,ASMPC+3
	scf
	call	c,%2
=
	call	z,%2

	call	l_gchar
	push	hl
	ld	hl,%1	;const
	add	hl,sp
	call	l_gchar
	pop	de
	ld	a,l
	sub	e
=
	ld	e,(hl)
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	ld	a,(hl)
	sub	e

	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	ld	a,l
	sub	e
=
	ld	a,%eval(%1 256 %%)
	sub	(hl)

	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	ld	a,e
	sub	l
=
	ld	a,(hl)
	sub	%eval(%1 256 %%)

	call	l_gchar
	ld	de,%1	;const
	ex	de,hl
	ld	a,e
	sub	l
=
	ld	a,(hl)
	sub	%eval(%1 256 %%)

	xor	a
	sub	(hl)
	and	a
	jr	nz,ASMPC+3
	scf
	jp	nc,%1	;%5
=
	ld	a,(hl)
	and	a
	jp	nz,%1	;%5

	ld	l,a
	ld	h,0
	ld	de,%1	;const
	ex	de,hl
	ld	a,l
	sub	e
	and	a
	jr	nz,ASMPC+3
	scf
	jp	nc,%2	;%5
=
	cp	%eval(%1 256 %%)
	jp	nz,%2	;%5

%check 0 <= %3 <= 255
	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
	%"and|or|xor|add|sub"	%3
	ld	l,a
	ld	h,0
	pop	de
	ld	a,e
=
	ld	e,(hl)
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	ld	a,(hl)
	%2	%3
	ld	l,a
	ld	h,0
	ld	a,e

	and	a
	jr	nz,ASMPC+3
	scf
	jp	%2c,%1	;%5
=
	and	a
	jp	%2z,%1	;%5

%title Zero check on 8080
	and	a
	jp	nz,ASMPC+4
	scf
	jp	%2c,%1	;%5
=
	and	a
	jp	%2z,%1	;%5

	ld	l,(hl)
	ld	h,0
	ld	a,l
	and	a
	jp	%2z,%1	;%5
=
	ld	a,(hl)
	and	a
	jp	%2z,%1	;%5

	ld	hl,(%1)
	ld	h,0
	ld	de,%2	;const
	ex	de,hl
=
	ld	a,(%1)
	ld	e,a
	ld	d,0
	ld	hl,%2	;const

	ex	de,hl
	ld	a,h
	or	l
	jp	z,%1	;%5
	ld	hl,%2
=
	ld	a,d
	or	e
	jp	z,%1	;%5
	ld	hl,%2

	ld	hl,1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
=
	pop	hl
	push	hl
	ld	l,h
	ld	h,0

	ld	l,a
	ld	h,0
	ld	de,%1
	ex	de,hl
=
	ld	e,a
	ld	d,0
	ld	hl,%1

	ld	l,(hl)
	ld	h,0
	%1c	l
	ld	hl,%2
=
	ld	hl,%2

	jp	%1	;%5


.%1
=

	pop	hl
	push	hl
	pop	bc
=
	pop	hl

	push	hl
	pop	de
	push	de
=
	push	hl
	ld	d,h
	ld	e,l

%notcpu 8080
%notcpu 8085
	push	hl
	call	l_gint	;
	inc	hl
	pop	de
	call	l_pint
=
	inc	(hl)
	ld	a,(hl)
	inc	hl
	jr	nz,ASMPC+3
	inc	(hl)
	ld	h,(hl)
	ld	l,a

%notcpu 8080
%notcpu 8085
	push	hl
	call	l_gint	;
	dec	hl
	pop	de
	call	l_pint
=
	dec	(hl)
	ld	a,(hl)
	inc	hl
	cp	255
	jr	nz,ASMPC+3
	dec	(hl)
	ld	h,(hl)
	ld	l,a

	jp	%1	;%5
.%2
	jp	%1	;%6
.%3
=
.%2
	jp	%1	;%5
.%3

	jp	z,%1	;%5
	jp	%2	;%6
.%1
=
	jp	nz,%2	;%6
.%1

	jp	%1	;%5
.%2
.%1
=
.%2
.%1

	ld	hl,%1	;const
	ld	(%2),hl
	ld	hl,%1	;const
=
	ld	hl,%1	;const
	ld	(%2),hl

	ex	de,hl
	ex	de,hl
=

	exx
	exx
=

	call	l_gint	;%2
	ld	hl,%1
=
	ld	hl,%1

	add	hl,sp
	ld	hl,%1
=
	ld	hl,%1

	push	hl
	call	l_gint	;%1
	ld	a,h
	and	%2
	ld	h,a
	ld	l,0
	pop	de
	call	l_pint
=
	inc	hl
	ld	a,(hl)
	and	%2
	ld	(hl),a
	dec	hl
	ld	(hl),0
	ld	h,a
	ld	l,0

	set	%1,d
	pop	de
=
	pop	de

	set	%1,e
	pop	de
=
	pop	de

	ld	de,0	;const
	ex	de,hl
	call	l_eq
	ccf
	jp	nc,%1	;%5
	pop	hl
=
	ld	a,h
	or	l
	jp	z,%1	;%5
	pop	hl

	ld	hl,0	;const
	call	l_eq
	jp	nc,%1	;%5
	ld	hl,%2
=
	ld	a,d
	or	e
	jp	nz,%1	;%5
	ld	hl,%2

%notcpu 8080
%notcpu 8085
	ld	hl,%1
	push	hl
	ld	hl,%2
	add	hl,hl
	pop	de
	add	hl,de
=
	ld	de,%1
	ld	hl,%2
	add	hl,hl
	add	hl,de

	ld	hl,%1	;const
	push	hl
	ld	hl,%2	;const
	add	hl,hl
	pop	de
	add	hl,de
=
	ld	de,%1
	ld	hl,%2	;const
	add	hl,hl
	add	hl,de

	ld	hl,%1
	push	hl
	ld	hl,%2
	%3c	hl
	add	hl,hl
	pop	de
	add	hl,de
=
	ld	de,%1
	ld	hl,%2
	%3c	hl
	add	hl,hl
	add	hl,de

	ld	e,a
	ld	d,0
	ld	a,d
	or	e
	jr	%1
=
	ld	e,a
	ld	d,0
	and	a
	jr	%1

%notcpu 8085
	call	l_gint	;%2
	ld	de,%1
	ex	de,hl
=
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	hl,%1

	ld	hl,%1
	push	hl
	ld	hl,%2
	push	hl
	pop	de
	pop	hl
=
	ld	hl,%1
	ld	de,%2

	ld	l,(hl)
	ld	h,0
	push	hl
	pop	de
=
	ld	e,(hl)
	ld	d,0

	ld	sp,hl
	ld	hl,0	;const
	add	hl,sp
=
	ld	sp,hl

%notcpu gbz80
	call	memset
	pop	bc
	pop	bc
	pop	bc
=
	call	memset_callee

%notcpu gbz80
	call	memcpy
	pop	bc
	pop	bc
	pop	bc
=
	call	memcpy_callee

	push	hl
	pop	de
	ld	a,%1
	ld	(de),a
	ld	hl,%2
=
	ld	(hl),%1
	ld	hl,%2

	push	hl
	push	bc
	pop	bc
	pop	hl
=


	ld	hl,%1	;const
	dec	sp
	ld	a,l
	pop	hl
	ld	l,a
	push	hl
=
	dec	sp
	pop	hl
	ld	l,%eval(%1 256 %%)
	push	hl

	dec	sp
	pop	hl
	ld	l,%1
	push	hl
	dec	sp
	pop	hl
	ld	l,%2
	push	hl
=
	ld	hl,%eval(%1 256 * %2 +)
	push	hl

%check 0 <= %1 <= 127
	ld	hl,%1	;const
	ld	a,l
	call	l_sxt
=
	ld	hl,%1	;const

%notcpu gbz80
	push	hl
	ld	hl,%1
	pop	de
=
	ex	de,hl
	ld	hl,%1

	ld	hl,%1	;const
	ld	a,l
	call	l_sxt
=
	ld	a,%eval(%1 256 %%)
	call	l_sxt

	ex	de,hl
	call	l_eq
=
	call	l_eq

	ex	de,hl
	call	l_ne
=
	call	l_ne

%notcpu gbz80
	push	hl
	pop	bc
	pop	hl
	push	hl
	push	bc
=
	pop	de
	push	de
	push	hl
	ex	de,hl

%cpu gbz80
	push	hl
	pop	bc
	pop	hl
	push	hl
	push	bc
	pop	de
=
	ld	d,h
	ld	e,l
	pop	hl
	push	hl

%notcpu 8080
%notcpu 8085
	ld	hl,(%1)
	pop	de
	push	de
	push	hl
	ex	de,hl
=
	pop	hl
	push	hl
	ld	de,(%1)
	push	de

	ld	hl,%1	;const
	pop	de
	push	de
	push	hl
	ex	de,hl
=
	pop	hl
	push	hl
	ld	bc,%1
	push	bc

%notcpu gbz80
	ld	hl,_%1
	pop	de
	push	de
	push	hl
	ex	de,hl
=
	pop	hl
	push	hl
	ld	bc,_%1
	push	bc

	ld	h,a
	ld	l,0
	ld	a,h
	or	l
	jp	%1,%2	;%5
=
	ld	h,a
	ld	l,0
	and	a
	jp	%1,%2	;%5

%notcpu gbz80
	ld	hl,_%1
	ld	(hl),%2
	inc	hl
	ld	(hl),%3
	ld	hl,%4
=
	ld	hl,%eval(%3 256 * %2 +)	;const
	ld	(_%1),hl
	ld	hl,%4

	call	l_gintspsp	;
	pop	hl
=
	add	hl,sp
	call	l_gint

	ld	l,(hl)
	ld	h,0
	ld	de,0
	ld	d,e
	ld	e,h
	ld	h,l
	ld	l,0
=
	ld	h,(hl)
	ld	l,0
	ld	de,0

	ld	de,0
	call	l_long_or
=
	pop	de
	call	l_or
	pop	de

	ld	l,(hl)
	ld	h,0
	ld	de,0
	ld	d,l
	ld	e,0
	ld	hl,0	;const
=
	ld	d,(hl)
	ld	e,0
	ld	h,e
	ld	l,h

	ld	de,0
	ld	l,0
	rl	d
	rl	l
	rl	d
	rl	l
	ld	h,0
	ld	de,0
=
	ld	hl,0	;const
	ld	de,0

%notcpu gbz80
	ld	h,(hl)
	ld	l,0
	pop	de
	call	l_or
=
	pop	de
	ld	a,d
	or	(hl)
	ld	d,a
	ex	de,hl

	call	l_glong
	ld	d,e
	ld	e,h
	ld	h,l
	ld	l,0
=
	ld	a,(hl)
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	h,a
	ld	l,0

	call	l_glong
	ld	l,d
	ld	h,0
	ld	de,0
	ld	h,0
=
	inc	hl
	inc	hl
	inc	hl
	ld	l,(hl)
	ld	h,0
	ld	de,0

%notcpu gbz80
	call	l_glong
	ld	l,h
	ld	h,e
	ld	e,d
	ld	d,0
=
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	l,(hl)
	ld	h,0
	ex	de,hl

$notcpu 8085
	call	l_gint	;
	call	l_glong
=
	call	l_glonghlp

	ld	hl,%1
	ld	hl,%2	;const
=
	ld	hl,%2	;const

	call	l_glong
	ex	de,hl
	ld	de,0
=
	inc	hl
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ld	de,0

	ld	e,(hl)
	ld	d,0
	ld	hl,0	;const
	call	l_long_or
=
	ld	a,(hl)
	pop	hl
	pop	de
	or	e
	ld	e,a

	ld	hl,%1	;const
	call	l_gintspsp	;
	ld	hl,%2
	pop	de
=
	ld	hl,%1	;const
	add	hl,sp
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	hl,%2

	ld	l,%1
	ld	h,%2
	pop	de
	ex	de,hl
=
	ld	e,%1
	ld	d,%2
	pop	hl

	push	hl
	ld	hl,%1
	ld	de,%2
	pop	bc
	call	l_plong
=
	ld	b,h
	ld	c,l
	ld	hl,%1
	ld	de,%2
	call	l_plong

%notcpu gbz80
	call	l_glong
	push	de
	push	hl
	ld	hl,%1
=
	call	l_glong2sp
	ld	hl,%1

%notcpu 8085
%notcpu gbz80
	call	l_glonghlp
	push	de
	push	hl
=
	call	l_glong2sp_hlp

	ld	b,h
	ld	c,l
	ld	hl,%1	;const
	ld	de,%2
	call	l_plong
	ld	hl,%3
=
	ld	(hl),%eval(%1 256 %%)
	inc	hl
	ld	(hl),%eval(%1 256 /)
	inc	hl
	ld	(hl),%eval(%2 256 %%)
	inc	hl
	ld	(hl),%eval(%2 256 /)
	ld	hl,%3

	ld	h,%1
	ld	h,%2
=
	ld	h,%2

	ld	l,h
	ld	h,0
	ex	de,hl
	ld	hl,%1
=
	ld	e,h
	ld	d,0
	ld	hl,%1

	pop	de
	push	de
	push	hl
	ex	de,hl
	pop	de
=
	pop	de
	push	de
	ex	de,hl

	call	l_gintspsp	;
	ld	hl,%1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	pop	de
=
	add	hl,sp
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0

	ld	hl,0	;const
	add	hl,sp
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
=
	pop	de
	push	de

	ld	l,(hl)
	ld	h,0
	pop	de
	push	de
	ex	de,hl
=
	ld	e,(hl)
	ld	d,0
	pop	hl
	push	hl

%notcpu 8085
	push	de
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;
	pop	de
=
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	call	l_gint

	ld	l,(hl)
	ld	h,0
	ld	a,l
	and	%1
	ld	l,a
=
	ld	a,(hl)
	and	%1
	ld	l,a
	ld	h,0

	ld	h,0
	ld	h,0
=
	ld	h,0

	ld	l,a
	ld	h,0
	ld	a,h
	or	l
	jp	%1	;%5
=
	ld	l,a
	ld	h,0
	and	a
	jp	%1	;%5

	ld	l,(hl)
	ld	h,0
	%3c	l
.i%1
	ld	hl,%2
=
.i%1
	ld	hl,%2

%notcpu 8080
%notcpu 8085
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
	add	hl,hl
=
	sla	l
	ld	h,l
	ld	l,0

%notcpu 8080
%notcpu 8085
	ld	h,0
	srl	l
	add	hl,hl
	add	hl,hl
=
	ld	h,0
	add	hl,hl

%notcpu 8080
%notcpu 8085
	ld	h,0
	srl	h
	rr	l
=
	ld	h,0
	srl	l

%notcpu 8080
%notcpu 8085
	ld	h,0
	srl	l
	srl	h
	rr	l
=
	ld	h,0
	srl	l
	srl	l

	ld	hl,(_%1)
	inc	hl
	ld	(_%1),hl
	dec	hl
	ld	hl,(_%1)
=
	ld	hl,(_%1)
	inc	hl
	ld	(_%1),hl

	and	%1
	and	a
=
	and	%1

	ld	l,(hl)
	ld	h,0
	ld	de,%1
	add	hl,de
	ld	h,0
=
	ld	a,(hl)
	ld	de,%1
	add	e
	ld	l,a
	ld	h,0

%notcpu 8080
%notcpu 8085
	ld	e,(hl)
	ld	d,0
	ld	hl,2
	call	l_asr_u
=
	ld	a,(hl)
	srl	a
	srl	a
	ld	l,a
	ld	h,0
	ld	de,255

	ld	l,a
	ld	h,0
	ld	a,l
	and	%1
	ld	l,a
	ld	h,0
=
	and	%1
	ld	l,a
	ld	h,0

	ld	l,(hl)
	ld	h,0
	add	hl,hl
	add	hl,hl
	add	hl,hl
	ld	h,0
=
	ld	a,(hl)
	add	a
	add	a
	add	a
	ld	l,a
	ld	h,0

	ld	h,0
	pop	de
	call	l_or
=
	pop	de
	ld	h,d
	ld	a,l
	or	e
	ld	l,a

%notcpu 8080
%notcpu 8085
	ld	l,0
	ld	a,1
	call	l_long_aslo
=
	ld	l,0
	sla	h
	rl	e
	rl	d

	ld	hl,0	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
=
	pop	hl
	push	hl
	ld	h,0

	scf
	jr	z,ASMPC+3
	ccf
	call	c,%1
=
	call	z,%1

	scf
	jr	z,ASMPC+3
	ccf
	jp	nc,%1	;%5
=
	jp	nz,%1	;%5

	jr	z,ASMPC+3
	scf
	jp	nc,%1	;%5
=
	jp	z,%1	;%5

	scf
	jr	z,ASMPC+3
	ccf
	ld	hl,0	;const
	rl	l
=
	ld	hl,1	;const
	jr	z,ASMPC+3
	dec	hl

	jr	z,ASMPC+3
	scf
	ld	hl,0	;const
	rl	l
=
	ld	hl,0	;const
	jr	z,ASMPC+3
	inc	hl

	ld	l,(hl)
	ld	h,0
	ld	a,l
	cp	%1
	ld	hl,%2
	jr	%3z,%4
=
	ld	a,%1
	cp	(hl)
	ld	hl,%2
	jr	%3z,%4

	jr	nz,ASMPC+3
	scf
	ld	hl,0	;const
	rl	l
=
	ld	hl,0	;const
	jr	nz,ASMPC+3
	inc	l

	ld	l,(hl)
	ld	h,0
	ld	a,%1
	sub	l
	ld	hl,%2	;const
=
	ld	a,%1
	sub	(hl)
	ld	hl,%2	;const

	ld	l,(hl)
	ld	h,0
	ld	a,l
	sub	%1
	ld	hl,%2
=
	ld	a,(hl)
	sub	%1
	ld	hl,%2

	ld	l,(hl)
	ld	h,0
	ld	a,%1
	sub	l
	ccf
	ld	hl,%2
=
	ld	a,%1
	sub	(hl)
	ccf
	ld	hl,%2

	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	sub	%2
	jp	c,%4	;%5
	ld	hl,%3
=
	ld	a,(_%1)
	sub	%2
	jp	c,%4	;%5
	ld	hl,%3

	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	sub	%2
	ccf
	jp	c,%3	;%5
	ld	hl,%4
=
	ld	a,(_%1)
	sub	%2
	jp	nc,%3	;%5
	ld	hl,%4

	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	sub	%2
	jp	nc,%3	;%5
	ld	hl,%4
=
	ld	a,(_%1)
	sub	%2
	jp	nc,%3	;%5
	ld	hl,%4

	pop	hl
	push	hl
	ld	l,h
	ld	h,0
	ld	a,l
	cp	%1
=
	ld	hl,1	;const
	add	hl,sp
	ld	a,(hl)
	cp	%eval(%1 256 %%)

	pop	hl
	push	hl
	ld	h,0
	ld	a,l
	cp	%1
=
	ld	hl,0	;const
	add	hl,sp
	ld	a,(hl)
	cp	%eval(%1 256 %%)

	pop	bc
	pop	hl
	push	hl
	push	bc
	ld	de,%1
	ex	de,hl
=
	pop	bc
	pop	de
	push	de
	push	bc
	ld	hl,%1

	jr	nz,ASMPC+3
	scf
	jp	c,%1	;%5
=
	jp	z,%1	;%5

	ld	hl,0	;const
	jr	nz,ASMPC+3
	inc	l
	ld	a,h
	or	l
	ld	hl,0	;const
	jr	nz,ASMPC+3
	inc	l
=
	ld	hl,1	;const
	jr	nz,ASMPC+3
	dec	l

	ld	hl,1	;const
	jr	z,ASMPC+3
	dec	hl
	ld	a,h
	or	l
	ld	hl,0	;const
	jr	nz,ASMPC+3
	inc	l
=
	ld	hl,0
	jr	z,ASMPC+3
	inc	l

	call	l_declong
.i_%1
	ld	hl,%2
=
.i_%1
	ld	hl,%2

	call	l_inclong
.i_%1
	ld	hl,%2
=
.i_%1
	ld	hl,%2

	pop	bc
	pop	hl
	push	hl
	push	bc
	ld	bc,%1
	add	hl,bc
	pop	de
	pop	bc
	push	hl
	push	de
=
	pop	de
	pop	hl
	ld	bc,%1
	add	hl,bc
	push	hl
	push	de

	ld	h,(hl)
	ld	l,a
	%1c	hl
	pop	hl
	push	hl
=
	pop	hl
	push	hl

	ld	de,0
	ld	hl,%1
	call	l_asr_u
	inc	e
=
	ld	hl,0	;const
	ld	de,0

	ld	hl,0	;const
	ld	de,0
	pop	bc
	add	hl,bc
	ex	de,hl
	pop	bc
	adc	hl,bc
	ex	de,hl
=
	pop	hl
	pop	de

	push	hl
	call	l_glong2sp
	pop	hl
	pop	de
	pop	bc
	call	l_plong
=
	call	l_glong

	call	l_g%3
.i_%1
	ld	hl,%2
=
.i_%1
	ld	hl,%2

	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;
	ld	bc,%2
	add	hl,bc
.i_%3
	ld	hl,%4
=
.i_%3
	ld	hl,%4

	call	l_glong
	ld	hl,%1
=
	inc	hl
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	hl,%1

	push	de
	ld	hl,%1
	add	hl,de
	pop	bc
	push	hl
=
	ld	hl,%1
	add	hl,de
	push	hl

	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	cp	%2
	jp	nz,%3	;%5
	ld	hl,%4
=
	ld	a,(_%1)
	cp	%2
	jp	nz,%3	;%5
	ld	hl,%4

	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	and	128
	jp	z,%2	;%5
	ld	hl,%3
=
	ld	a,(_%1)
	rlca
	jp	nc,%2	;%5
	ld	hl,%3

%eval 2 = %2 %1 -
	ld	hl,%1	;const
	add	hl,sp
	push	hl
	ld	hl,%2	;const
	add	hl,sp
=
	ld	hl,%1	;const
	add	hl,sp
	push	hl

	push	de
	push	hl
	ld	hl,0	;const
	add	hl,sp
	call	l_glong
=
	push	de
	push	hl

	ld	de,%1
	ld	a,l
	ld	l,h
	ld	h,a
	ld	de,%2
=
	ld	a,l
	ld	l,h
	ld	h,a
	ld	de,%2

	call	l_glong
	ld	a,l
	ld	l,d
	ld	d,a
	ld	a,h
	ld	h,e
	ld	e,a
=
	ld	d,(hl)
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	l,(hl)
	ld	h,a

	ld	hl,(_%1)
	ld	h,0
	add	hl,de
	ld	h,0
	ld	a,l
	ld	(_%2),a
	%3	hl%4
=
	ld	a,(_%1)
	add	e
	ld	(_%2),a
	%3	hl%4

	call	l_glong
	ld	de,0
=
	call	l_gint
	ld	de,0

	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	cp	%2
	ld	hl,%3
=
	ld	a,(_%1)
	cp	%2
	ld	hl,%3

	ld	h,0
	ld	a,l
	and	%2
	ld	l,a
	ld	h,0
=
	ld	h,0
	ld	a,%2
	and	l
	ld	l,a

	ld	l,(hl)
	ld	h,0
	call	l_sxt
=
	ld	a,(hl)
	call	l_sxt

	ld	hl,(_%1)
	ld	h,0
	call	l_lneg
	jp	nc,%2	;%5
=
	ld	a,(_%1)
	and	a
	jp	nz,%2	;%5

	ld	l,(hl)
	ld	h,0
	call	l_lneg
	jp	c,%1	;%5
=
	ld	a,(hl)
	and	a
	jp	z,%1	;%5

	ld	l,(hl)
	ld	h,0
	ld	a,l
	sub	%1
	jp	%2c,%3	;%5
=
	ld	a,(hl)
	sub	%1
	jp	%2c,%3	;%5

	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	call	l_sxt
=
	ld	a,(_%1)
	ld	l,a
	rla
	sbc	a
	ld	h,a

	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	and	%2
	jp	z,%3	;%5
	ld	hl,%4
=
	ld	a,(_%1)
	and	%2
	jp	z,%3	;%5
	ld	hl,%4

	ld	hl,(_%1)
	ld	h,0
	ld	de,4
	call	l_asr_u_hl_by_e
=
	ld	a,(_%1)
	rra
	rra
	rra
	rra
	and	15
	ld	l,a
	ld	h,0

	ld	d,(hl)
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	l,(hl)
	ld	h,a
	ld	a,l
	and	%1
	ld	l,a
	ld	h,0
	ld	de,0
=
	inc	hl
	inc	hl
	inc	hl
	ld	a,(hl)
	and	%1
	ld	l,a
	ld	h,0
	ld	de,0

	ld	l,a
	ld	h,0
	ld	de,0
	ld	a,h
	or	l
	jp	z,%2	;%5
	ld	hl,%3
=
	and	a
	jp	z,%2	;%5
	ld	hl,%3

	ld	d,(hl)	;broken
	inc	hl
	ld	e,(hl)
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	l,(hl)
	ld	h,a
	ld	a,l
	ld	l,d
	ld	d,a
	ld	a,h
	ld	h,e
	ld	e,a
=
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ex	de,hl

%notcpu 8080
%notcpu 8085
	push	hl
	ld	l,(hl)
	ld	h,0
	srl	l
	pop	de
	ld	a,l
	ld	(de),a
=
	srl	(hl)

	call	l_ghtonsint
	ld	a,h
	and	%1
	ld	h,a
	ld	l,0
=
	ld	a,(hl)
	and	%1
	ld	h,a
	ld	l,0

	and	%1
	ld	h,a
	ld	l,0
	and	a
	jp	z,%2	;%5
	ld	hl,%3
=
	and	%1
	jp	z,%2	;%5
	ld	hl,%3

	ld	hl,(_%1)
	ld	h,0
	ld	a,%2
	and	l
	ld	l,a
	push	hl
=
	ld	a,(_%1)
	and	%2
	ld	l,a
	ld	h,0
	push	hl

	scf
	jr	z,ASMPC+3
	and	a
	jr	c,%2
.%3
	jp	%4	;%5
.%2
=
	scf
	jr	z,%2
	and	a
.%3
	jp	%4	;%5
.%2

	ld	hl,(_%1)
	ld	h,0
	ld	de,0
	ld	d,e
	ld	e,h
	ld	h,l
	ld	l,0
=
	ld	hl,(_%1 - 1)
	ld	l,0
	ld	de,0

	ld	l,(hl)
	ld	h,0
	ld	a,l
	sub	e
	and	a
	jp	z,%1	;%5
	pop	hl
=
	ld	a,(hl)
	sub	e
	and	a
	jp	z,%1	;%5
	pop	hl

	call	l_glong2sp
	ld	hl,%1	;const
	ld	de,0
	call	l_long_and
	pop	de
	call	l_pint
	ld	hl,%2
=
	pop	bc
	ld	a,(hl)
	and	%eval(%1 256 %%)
	ld	(bc),a
	inc	bc
	inc	hl
	ld	a,(hl)
	and	(%1 / 256)
	ld	(bc),a
	ld	hl,%2

	push	hl
	ld	hl,%1	;const
	add	hl,sp
	pop	bc
=
	ld	c,l
	ld	b,h
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp

%notcpu 8080
%notcpu 8085
%check 0 <= %1 <= 7
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	l,(hl)
	ld	h,0
	ex	de,hl
	ld	c,%1
	call	l_long_asr_uo
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	b,%1
.i_x%L	rr	h
	rra
	djnz	i_x%L
	pop	de
	ld	(de),a
	ld	hl,%2

	ld	h,0
	ld	de,3
	call	l_asr_u_hl_by_e
	ld	a,l
	and	%1
=
	ld	a,l
	rra
	rra
	rra
	and	31
	and	%1
	ld	l,a

	ld	l,a
	ld	l,a
=
	ld	l,a

	ld	l,a
	ld	h,0
	ld	a,l
=
	ld	l,a
	ld	h,0

	ld	h,0
	ld	de,6
	call	l_asr_u_hl_by_e
	ld	h,0
=
	ld	a,l
	rlca
	rlca
	and	3
	ld	l,a
	ld	h,0

	ld	l,a
	ld	h,0
	ld	(_%1),a
	pop	hl
=
	ld	(_%1),a
	pop	hl

	ld	h,0
	ld	de,4
	call	l_asr_u_hl_by_e
=
	ld	h,0
	ld	a,l
	rrca
	rrca
	rrca
	rrca
	and	15
	ld	l,a

	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	and	a
	jp	%2	;%5
	ld	hl,%3
=
	ld	a,(_%1)
	and	a
	jp	%2	;%5
	ld	hl,%3

	ld	hl,%1	;const
	add	hl,sp
	push	hl
	ld	hl,%2	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	%3c	hl
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%4
=
	ld	hl,%2	;const
	add	hl,sp
	ld	a,(hl)
	%3c	a
	ld	hl,%1	;const
	add	hl,sp
	ld	(hl),a
	ld	hl,%4

	push	hl
	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	add	hl,de
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
	ld	a,(hl)
	ex	de,hl
	ld	hl,%eval(%1 2 -)	;const
	add	hl,sp
	add	(hl)
	ld	(de),a
	ld	hl,%2

%notcpu gbz80
	push	de
	ld	l,e
	ld	h,d
	pop	bc
=
	ex	de,hl

	push	hl
	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
	pop	de
	ld	(de),a
	ld	hl,%2
=
	ex	de,hl
	ld	hl,%eval( %1 2 -)	;const
	add	hl,sp
	ld	a,(hl)
	ld	(de),a
	ld	hl,%2

	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
	ld	(de),a
	ld	hl,%1	;const
	add	hl,sp
=
	ld	hl,%1
	add	hl,sp
	ld	a,(hl)
	ld	(de),a

	ld	(de),a
	ld	a,(hl)
=
	ld	(de),a

	ld	hl,0	;const
	ld	de,0
	call	l_long_add
=
	pop	de
	pop	hl

	push	hl
	call	l_glong2sp
	pop	de
	pop	hl
	pop	bc
	call	l_plong
=
	call	l_glong

	ld	l,(hl)
	ld	h,l
	ld	l,0
=
	ld	h,(hl)
	ld	l,0

	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	hl,%1	;const
	call	l_pint
	ld	hl,%2
=
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
	ld	(hl),%eval(%1 256 %%)
	inc	hl
	ld	(hl),%eval(%1 256 /)
	ld	hl,%2

	ld	(hl),0
	inc	hl
	ld	(hl),0
=
	xor	a
	ld	(hl),a
	inc	hl
	ld	(hl),a

	ld	l,a
	ld	h,0
	call	l_lneg
	jp	%2c,%1	;%5
=
	and	a
	jp	%2z,%1	;%5

%notcpu 8080
%notcpu 8085
	push	hl
	call	l_gint	;
	res	%1,l
	pop	de
	call	l_pint
=
	res	%1,(hl)
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a

	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a
.%1
	ld	hl,%2	;const
=
.%1
	ld	hl,%2	;const

%check 0 <= %1 <= 127
	call	l_gchar
	ld	de,%1
	and	a
	sbc	hl,de
	jp	%2,%3	;%5
	ld	hl,%4
=
	ld	a,(hl)
	cp	%1
	jp	%2,%3	;%5
	ld	hl,%4

	call	l_gchar
	ld	a,l
	cp	%1
	jp	%2,%3	;%5
	ld	hl,%4
=
	ld	a,(hl)
	cp	%1
	jp	%2,%3	;%5
	ld	hl,%4

	call	l_gchar
	ld	a,l
	and	a
	jp	%1	;%5
	ld	hl,%2
=
	ld	a,(hl)
	and	a
	jp	%1	;%5
	ld	hl,%2

	call	l_gchar
	ld	a,l
	call	l_sxt
=
	call	l_gchar

	call	l_gchar
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%1
=
	pop	de
	ld	a,(hl)
	ld	(de),a
	ld	hl,%1

%check 0 <= %1 <= 127
	call	l_gchar
	ld	de,%1
	and	a
	sbc	hl,de
	scf
	jr	%2,ASMPC+3
	ccf
	j%4	%3
=
	ld	a,(hl)
	cp	%1
	scf
	jr	%2,ASMPC+3
	ccf
	j%4	%3

%check 0 <= %1 <= 65535
	inc	hl
	ld	bc,%1
	add	hl,bc
=
	ld	bc,%eval( %1 1 +)
	add	hl,bc

%check 0 <= %1 <= 65535
	dec	hl
	ld	bc,%1
	add	hl,bc
=
	ld	bc,%eval( %1 1 -)
	add	hl,bc

	push	hl
	ld	hl,0	;const
	call	l_gintspsp	;%1
=
	push	hl
	push	hl

	ld	l,(hl)
	ld	h,0
	ld	de,6
	call	l_asr_u_hl_by_e
	ld	a,l
	and	3
	ld	l,a
=
	ld	a,(hl)
	rlca
	rlca
	and	3
	ld	l,a
	ld	h,0

	ld	l,(hl)
	ld	h,0
	ld	a,l
	ld	(%1),a
	ld	hl,%2
=
	ld	a,(hl)
	ld	(%1),a
	ld	hl,%2

	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ld	de,0	;
	ld	h,0
=
	ld	l,(hl)
	ld	h,0
	ld	de,0

	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	inc	hl
	ld	l,(hl)
	ld	h,0
	ex	de,hl
	ld	h,0
=
	ld	e,(hl)
	inc	hl
	inc	hl
	ld	l,(hl)
	ld	h,0
	ex	de,hl
	ld	h,0

%check 9 <= %1 <= 15
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	hl,%1
	call	l_asr_u
=
	inc	hl
	ld	e,(hl)
	ld	d,0
	ld	hl,%eval(%1 8 -)
	call	l_asr_u

	ld	de,255
	inc	e
=
	ld	de,0

	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	ld	de,0
	ld	h,0
=
	ld	l,(hl)
	ld	h,0
	ld	de,0

	sbc	hl,de
	jp	nz,%1	;%5
	ld	hl,0	;const
=
	sbc	hl,de
	jp	nz,%1	;%5

	push	hl
	ld	hl,%1	;const
	add	hl,sp
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ex	de,hl
	pop	de
=
	ex	de,hl
	ld	hl,%eval(%1 2 -)	;const
	add	hl,sp
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a

	call	l_glong
	ld	de,%1
=
	call	l_gint
	ld	de,%1

	ld	de,0
	ld	a,d
	or	e
	or	h
	or	l
=
	ld	de,0
	ld	a,h
	or	l

	ld	hl,%1
	push	hl
	ld	hl,%2	;const
	add	hl,sp
	ex	de,hl
	pop	bc
=
	ld	hl,%eval(%2 2 -)	;const
	add	hl,sp
	ex	de,hl
	ld	bc,%1

	ld	hl,%1	;const
	add	hl,sp
	ld	sp,hl
	ld	hl,%2	;const
	add	hl,sp
	ld	sp,hl
=
	ld	hl,%eval(%1 %2 + 65536 %%)	;const
	add	hl,sp
	ld	sp,hl

	ld	de,%1	;const
	ex	de,hl
	ld	a,l
	rlca
=
	ld	de,%eval(%1 1 <)	;const
	ex	de,hl
	ld	a,l

	ld	hl,%1
	ld	de,%2	;const
	ex	de,hl
	ld	a,l
	and	%3
	ld	l,a
	ld	a,(de)
	and	%4
	or	l
	ld	(de),a
	ld	hl,%5
=
	ld	hl,%1
	ld	a,(hl)
	and	%4
	or	%eval( %2 256 %% %3 &)
	ld	(hl),a
	ld	hl,%5

	ld	hl,_%1+%3
	ld	de,%2
	ex	de,hl
	inc	de
=
	ld	hl,_%1+%eval(%3 1 +)
	ld	de,%2
	ex	de,hl

	ld	hl,_%1
	ld	de,%2
	ex	de,hl
	inc	de
=
	ld	hl,_%1 + 1
	ld	de,%2
	ex	de,hl

	ld	hl,%1	;const
	add	hl,hl
=
	ld	hl,%eval(%1 2 *)	;const

%check 0 <= %2 <= 65535
	ld	hl,%1	;const
	ld	de,%2
	call	l_and
=
	ld	hl,%eval(%1 %2 &)

%check 0 <= %2 <= 65535
	ld	hl,%1	;const
	ld	de,%2
	call	l_or
=
	ld	hl,%eval(%1 %2 |)

	ld	a,(de)
	and	0
	or	l
	ld	(de),a
=
	ld	a,l
	ld	(de),a

	ld	a,(de)
	and	0
	or	h
	ld	(de),a
=
	ld	a,h
	ld	(de),a

%check 0 <= %1 <= 65535
	ld	de,%2
	ld	hl,%1
	ld	a,l
	ld	(de),a
	inc	de
	ld	a,(de)
	and	%3
	or	h
	ld	(de),a
	ld	hl,%4
=
	ld	hl,%2
	ld	(hl),%eval(%1 256 %%)
	inc	hl
	ld	a,(hl)
	and	%3
	or	%eval(%1 256 /)
	ld	(hl),a
	ld	hl,%4

	ld	hl,%1	;const
	ld	(%2),hl
	ld	hl,%1
=
	ld	hl,%1	;const
	ld	(%2),hl

	ld	a,l
	and	255
	ld	l,a
=


	ld	hl,%1
	ld	de,%4	;const
	ex	de,hl
	ld	a,l
	and	%2
	ld	l,a
	ld	a,(de)
	and	%3
	or	l
	ld	(de),a
=
	ld	hl,%1
	ld	a,(hl)
	and	%3
	or	%eval(%4 256 %% %2 &)
	ld	(hl),a
	ld	hl,%4

	ld	hl,%1
	ld	hl,_%2
=
	ld	hl,_%2

	or	0
=


	and	255
=


	ld	a,l
	ld	l,a
	ld	a,l
=
	ld	a,l

	ld	e,(hl)
	inc	hl
	ld	a,(hl)
	ld	h,a
	ld	l,e
=
	ld	a,(hl)
	inc	hl
	ld	h,(hl)
	ld	l,a

	scf
	jr	nz,ASMPC+3
	ccf
	jr	c,%1
.%2
	jp	%3	;%5
.%1
	ld	hl,%4
=
	jr	nz,%1
.%2
	jp	%3	;%5
.%1
	ld	hl,%4

	dec	hl
.%1
	ld	hl,%2
=
.%1
	ld	hl,%2

	ld	h,(hl)
	ld	l,a
	pop	hl
=
	pop	hl

	push	hl
	ld	a,(hl)
	cp	%1
	jp	%2	;%5
	pop	hl
	push	hl
	inc	hl
=
	push	hl
	ld	a,(hl)
	cp	%1
	jp	%2	;%5
	inc	hl

	push	hl
	ld	hl,0	;const
	ld	d,h
	ld	e,l
	pop	bc
	call	l_plong
	ld	hl,%1
	add	hl,sp
=
	xor	a
	ld	(hl),a
	inc	hl
	ld	(hl),a
	inc	hl
	ld	(hl),a
	inc	hl
	ld	(hl),a
	ld	hl,%1
	add	hl,sp

	ld	h,(hl)
	ld	l,a
.%1
	ld	hl,%2
=
.%1
	ld	hl,%2

	ld	a,h
	or	l
	jp	nz,%1	;%5
	jr	%2
.%1
	ld	hl,1	;const
.%2
	ld	a,h
	or	l
=
	ld	a,h
	or	l
	jr	z,%2
.%1
	ld	hl,1	;const
.%2
	ld	a,h
	or	l

	ld	l,(hl)
	ld	h,0
	ld	de,%1
	call	l_and
=
	ld	a,(hl)
	and	%eval(%1 256 %%)
	ld	l,a
	ld	h,0

	ld	l,a
	ld	h,0
	ex	de,hl
	ld	hl,%1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	call	l_or
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
	ld	hl,%1	;const
	add	hl,sp
	or	(hl)
	pop	de
	ld	(de),a
	ld	hl,%2

	ld	de,1
	and	a
	sbc	hl,de
	jp	nz,%1	;%5
	ld	hl,%2
=
	dec	hl
	ld	a,h
	or	l
	jp	nz,%1	;%5
	ld	hl,%2

	and	%1
	ld	h,a
	ld	l,0
	and	a
=
	and	%1
	ld	h,a
	ld	l,0

	ld	l,(hl)
	ld	h,0
	call	l_lneg
	jp	%1c,%2	;%5
=
	ld	a,(hl)
	and	a
	jp	%1z,%2	;%5

	ld	a,h
	and	255
	ld	h,a
=

%notcpu 8080
%notcpu 8085
	ld	a,(hl)
	or	128
	ld	(hl),a
	ld	l,a
	ld	h,0
=
	set	7,(hl)
	ld	l,(hl)
	ld	h,0

	ld	l,(hl)
	ld	h,0
	ld	a,l
	and	%1
	jp	%2,%3	;%5
	ld	hl,%4
=
	ld	a,%1
	and	(hl)
	jp	%2,%3	;%5
	ld	hl,%4

	call	l_gint	;
	ld	a,l
	and	%1
	ld	l,a
	ld	h,0
=
	ld	a,(hl)
	and	%1
	ld	l,a
	ld	h,0

	inc	hl
	inc	hl
	ld	(_%1),hl
	dec	hl
	dec	hl
	ld	(hl),%2
	inc	hl
	ld	(hl),%3
=
	ld	(hl),%2
	inc	hl
	ld	(hl),%3
	inc	hl
	ld	(_%1),hl

	call	l_gchar
	ld	h,0
=
	ld	l,(hl)
	ld	h,0

	call	l_gchar
	ld	a,h
	or	l
	jp	%1z,%2	;%3
	ld	hl,%4
=
	ld	a,(hl)
	and	a
	jp	%1z,%2	;%3
	ld	hl,%4

%check 0 <= %1 <= 255
	ld	a,l
	and	%1
	ld	l,a
	ld	h,0
	pop	de
	ld	a,l
	and	%1
	ld	l,a
=
	ld	a,l
	and	%1
	ld	l,a
	ld	h,0
	pop	de

%cpu gbz80
	ld	hl,_%1
	push	hl
	ld	hl,_%2
	pop	de
	push	de
=
	ld	de,_%1
	ld	hl,_%2
	push	de

	ld	hl,_%1
	ld	l,(hl)
	ld	h,0
	inc	hl
	ld	a,l
	ld	(_%1),a
	dec	hl
=
	ld	hl,_%1
	inc	(hl)
	ld	l,(hl)
	dec	l
	ld	h,0

	ld	l,(hl)
	ld	h,0
	ld	l,h
	ld	h,0
=
	ld	hl,0	;const

	ld	hl,%1	;const
	add	hl,sp
	ld	hl,%2	;const
=
	ld	hl,%2	;const

	ld	a,(hl)
	and	0
	ld	l,a
	ld	h,0
=
	ld	hl,0	;const

	ld	h,%1
	%"and|or|xor"3	%2
	ld	l,a
	ld	h,%1
=
	%3	%2
	ld	l,a
	ld	h,%1

	push	de
	push	hl
	ld	hl,%1	;const
	ld	de,%2
	call	l_f32_swap
=
	ld	bc,%2
	push	bc
	ld	bc,%1
	push	bc

	call	l_glong2sp
	ld	hl,%1	;const
	ld	de,%2
	call	l_f32_swap
=
	call	l_glong
	ld	bc,%2
	push	bc
	ld	bc,%1
	push	bc

	push	hl
	ld	hl,%1	;const
	ex	(sp),hl
=
	ld	bc,%1	;const
	push	bc

	call	l_gintspsp	;%2
	ld	hl,%1	;const
	ex	(sp),hl
=
	add	hl,sp
	call	l_gint
	ld	bc,%1	;const
	push	bc

	ld	l,e
	ld	h,d
	ex	de,hl
=
	ld	l,e
	ld	h,d

	call	l_i64_%12i64
	call	l_i64_%"asl|asr_u|asr"2
=
	ld	a,l
	call	l_i64_%2o

	call	l_i64_push
	ld	hl,0	;const
	add	hl,sp
	push	hl
	call	l_i64_load
=
	call	l_i64_push
	ld	hl,0	;const
	add	hl,sp
	push	hl

	ld	hl,%1
	call	l_i64_load
	call	l_i64_push_under_int
=
	ld	hl,%1
	call	l_i64_push_under_int_mhl

	ld	hl,%1	;const
	ld	b,l
	push	bc
	inc	sp
	ld	hl,%2	;const
	ld	b,l
	push	bc
	inc	sp
=
	ld	bc,%eval(%1 256 * %2 +)
	push	bc

%eval 2 = %2 %1 -
	ld	hl,%1	;const
	call	l_gintspsp	;
	ld	hl,%2	;const
	add	hl,sp
	call	l_gint	;
=
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;
	push	hl

	push	hl
	pop	de
=
	ld	d,h
	ld	e,l

	%"inc|dec"1	hl
.%2
	pop	hl
	push	hl
=
.%2
	pop	hl
	push	hl

%notcpu 8080
%notcpu 8085
%notcpu gbz80
	ld	hl,(%1)
	ld	de,(%1+2)
	push	de
	push	hl
	ld	hl,(%2)
	ld	de,(%2+2)
	call	l_long_sub
=
	ld	hl,(%1)
	ld	de,(%2)
	and	a
	sbc	hl,de
	ex	de,hl
	ld	hl,(%1+2)
	ld	bc,(%2+2)
	sbc	hl,bc
	ex	de,hl

%notcpu 8080
%notcpu 8085
%notcpu gbz80
	ld	hl,(%1)
	ld	de,(%1+2)
	push	de
	push	hl
	ld	hl,(%2)
	ld	de,(%2+2)
	call	l_long_add
=
	ld	hl,(%1)
	ld	de,(%2)
	add	hl,de
	ex	de,hl
	ld	hl,(%1+2)
	ld	bc,(%2+2)
	adc	hl,bc
	ex	de,hl

	ld	hl,(%1)
	ex	de,hl
	ld	hl,(%2)
	ex	de,hl
=
	ld	hl,(%2)
	ex	de,hl
	ld	hl,(%1)

	ld	h,0
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2

	ld	l,a
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%1
=
	pop	de
	ld	(de),a
	ld	hl,%1

	push	de
	ld	hl,%1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	add	hl,hl
	pop	de
=
	ld	hl,%eval(%1 2 -)	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	add	hl,hl

	pop	bc
	pop	hl
	push	hl
	push	bc
	%1c	h
	pop	de
	pop	bc
	push	hl
	push	de
=
	pop	bc
	pop	hl
	%1c	h
	push	hl
	push	bc

	jr	c,%1
.%2
	jp	i_%3	;%5
.%1
=
%activate
	jr	c,%1
.%2
	jp	i_%3	;%5
.%1
=
%once
	jp	nc,i_%3	;%5
.%1
%activate
; --- Start of Optimiser additions ---
=
%once
; --- Start of Optimiser additions ---
	defc	%2 = i_%3

	push	hl
	ld	hl,%2	;const
	add	hl,sp
	ld	a,(hl)
	pop	de
=
	ex	de,hl
	ld	hl,%eval(%2 2 -)	;const
	add	hl,sp
	ld	a,(hl)

%eval 0 = %2 %1 - !
.i_%1
	jp	i_%2	;%5
=
%activate
.i_%1
	jp	i_%2	;%5
=
%once
	jp	i_%2	;%5
%activate
; --- Start of Optimiser additions ---
=
%once
; --- Start of Optimiser additions ---
	defc	i_%1 = i_%2

	jr	i_%2
	jp	i_%3	;%5
=
	jr	i_%2

	jp	i_%2
	jp	i_%3
=
	jp	i_%2

	j%"r|p"0	i_%1
.i_%1
=
.i_%1

%notcpu 8080
%notcpu 8085
%notcpu gbz80
	call	l_gint	;%1
	call	l_pint
	ld	hl,%2
=
	ldi
	ldi
	ld	hl,%2

%check 0 <= %1 <= 255
	ld	h,%1
	dec	h
=
	ld	h,%eval(%1 1 - 256 %%)

%check 0 <= %1 <= 255
	ld	h,%1
	inc	h
=
	ld	h,%eval(%1 1 + 256 %%)

	ld	hl,_%1
	push	hl
	ld	hl,%2	;const
	add	hl,sp
	call	l_gint	;%4
	%3c	hl
	pop	de
=
	ld	hl,%eval(%2 2 -)	;const
	add	hl,sp
	call	l_gint	;%4
	%3c	hl
	ld	de,_%1

	call	l_gint	;
	ld	a,h
	or	l
	jp	z,%1	;%4
	pop	hl
=
	ld	a,(hl)
	inc	hl
	or	(hl)
	jp	z,%1	;%4
	pop	hl

	jp	i_%1	;%4
	jp	i_%3	;%5
=
	jp	i_%1	;%4

	ld	hl,%1	;const
	call	l_gintspsp	;%2
	ld	hl,%3	;const
	add	hl,sp
	call	l_gint	;%4
	pop	de
=
	ld	hl,%1	;const
	add	hl,sp
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	hl,%eval(%3 2 -)	;const
	add	hl,sp
	call	l_gint	;%4

%notcpu 8085
	ex	de,hl
	call	l_pint
=
	ld	(hl),e
	inc	hl
	ld	(hl),d
	ex	de,hl

%notcpu 8085
	call	l_gint	;%1
	ld	bc,%2
	add	hl,bc
=
	ld	c,(hl)
	inc	hl
	ld	b,(hl)
	ld	hl,%2
	add	hl,bc

	push	hl
	ld	l,(hl)
	ld	h,0
	ld	a,l
	or	%1
	ld	l,a
	pop	de
	ld	a,l
	ld	(de),a
=
	ld	a,(hl)
	or	%1
	ld	(hl),a
	ld	l,a
	ld	h,0

; Try to eliminate dead loads
=
; XXXX

	inc	%"h|l"2
	jp	%1	;EOS
=
	jp	%1	;EOS

	ld	l,%2
	ld	h,0
	jp	%1	;EOS
=
	jp	%1	;EOS

	ex	de,hl
	jp	%1	;EOS
=
	jp	%1	;EOS

	%1c	hl
	jp	%2	;EOS
=
	jp	%2	;EOS

	ld	h,%1
	ld	l,%2
	jp	%3	;EOS
=
	jp	%3	;EOS

	ld	l,(hl)
	ld	h,0
	ld	a,h
	or	l
	jp	nz,%1	;EOS
	jp	i_%3	;EOS
=
	ld	a,(hl)
	and	a
	jp	nz,%1	;EOS
	jp	i_%3	;EOS

	ld	de,32767
	call	l_and
=
	res	7,h

	ld	hl,_%1
	ld	b,h
	ld	c,l
	ld	hl,%2
=
	ld	bc,_%1
	ld	hl,%2

; bit fields
=
;

	ld	de,%2	;const
	ex	de,hl
	ld	a,l
	and	%4
	ld	l,a
	ld	a,(de)
	and	%3
	or	l
	ld	(de),a
=
	ld	a,(hl)
	and	%3
	or	%eval(%2 256 %% %4 &)
	ld	(hl),a

%notcpu 8080
%notcpu 8085
	rlca
	and	1
	jp	%5,%1	;%4
=
	bit	7,a
	jp	%5,%1	;%4

%notcpu 8080
%notcpu 8085
	rlca
	bit	%2,a
	jp	%5,%1	;%4
=
	bit	%eval(%2 1 -),a
	jp	%5,%1	;%4

	ld	de,0	;const
	ex	de,hl
	ld	a,l
	rrca
=
	ld	de,0	;const
	ex	de,hl
	ld	a,l

	rrca
	and	%2
	jp	%3z,%4	;%5
	ld	hl,%6
=
	and	%eval(%2 1 <)
	jp	%3z,%4	;%5
	ld	hl,%6

%notcpu 8080
%notcpu 8085
	ld	a,(hl)
	and	1
	jp	%2z,%3
	ld	hl,%4
=
	bit	0,(hl)
	jp	%2z,%3
	ld	hl,%4

%notcpu 8080
%notcpu 8085
	ld	a,(hl)
	and	2
	jp	%2z,%3
	ld	hl,%4
=
	bit	1,(hl)
	jp	%2z,%3
	ld	hl,%4

%notcpu 8080
%notcpu 8085
	ld	a,(hl)
	and	4
	jp	%2z,%3
	ld	hl,%4
=
	bit	2,(hl)
	jp	%2z,%3
	ld	hl,%4

%notcpu 8080
%notcpu 8085
	ld	a,(hl)
	and	8
	jp	%2z,%3
	ld	hl,%4
=
	bit	3,(hl)
	jp	%2z,%3
	ld	hl,%4

%notcpu 8080
%notcpu 8085
	ld	a,(hl)
	and	16
	jp	%2z,%3
	ld	hl,%4
=
	bit	4,(hl)
	jp	%2z,%3
	ld	hl,%4

%notcpu 8080
%notcpu 8085
	ld	a,(hl)
	and	32
	jp	%2z,%3
	ld	hl,%4
=
	bit	5,(hl)
	jp	%2z,%3
	ld	hl,%4

%notcpu 8080
%notcpu 8085
	ld	a,(hl)
	and	64
	jp	%2z,%3
	ld	hl,%4
=
	bit	6,(hl)
	jp	%2z,%3
	ld	hl,%4

%notcpu 8080
%notcpu 8085
	ld	a,(hl)
	and	128
	jp	%2z,%3
	ld	hl,%4
=
	bit	7,(hl)
	jp	%2z,%3
	ld	hl,%4

; Char operators
=
;

	ld	l,a
	pop	de
	ld	a,l
	ld	(de),a
=
	ld	l,a
	pop	de
	ld	(de),a

	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	call	l_eq
	jp	%2c,%3	;%4
	ld	hl,%5
=
	ld	a,(hl)
	ld	hl,%1	;const
	add	hl,sp
	cp	(hl)
	jp	%2z,%3	;%4
	ld	hl,%5

; Char constant comparisons
=
;

	ld	l,(hl)
	ld	h,0
	ld	a,%1
	sub	l
	jp	%2c,%3
=
	ld	a,%1
	sub	(hl)
	jp	%2c,%3

%check 0 <= %1 <= 255
	ld	l,a
	ld	h,0
	ld	de,%1
	and	a
	sbc	hl,de
	ld	hl,1	;const
	jr	%2z,ASMPC+3
	dec	hl
=
	sub	%eval(%1 256 %%)
	ld	hl,1	;const
	jr	%2z,ASMPC+3
	dec	hl

	ld	l,a
	ld	h,0
	ld	a,h
	or	l
	ld	hl,%2	;const
	jr	%3z,ASMPC+3
=
	and	a
	ld	hl,%2	;const
	jr	%3z,ASMPC+3

	push	hl
	ld	a,(hl)
	and	%1
	pop	de
	ld	(de),a
=
	ld	a,(hl)
	and	%1
	ld	(hl),a

	ld	l,(hl)
	ld	h,0
	ld	a,l
	cp	%1
	jp	%2z,%3	;%4
	ld	hl,%5	;const
=
	ld	a,(hl)
	cp	%1
	jp	%2z,%3	;%4
	ld	hl,%5	;const

%check 1 <= %1 <= 255
%title 16bit >= becomes 8bit >=
	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	call	l_uge
	jp	%2c,%3
	ld	hl,%4
=
	ld	a,%eval(%1 1 -)
	cp	(hl)
	jp	%2c,%3
	ld	hl,%4

%title 16 bit <= becomes 8 bit <=
%check 0 <= %2 <= 254
	ld	hl,(_%1)
	ld	h,0
	ld	de,%2
	ex	de,hl
	and	a
	sbc	hl,de
	ccf
	jp	%3c,%4
=
	ld	a,(_%1)
	cp	%eval(%2 1 +)
	jp	%3c,%4

	ld	hl,%1	;const
	ld	a,l
	ld	(de),a
	jp	%2	;EOS
=
	ld	a,%eval(%1 256 %%)
	ld	(de),a
	jp	%2	;EOS

; long logical operations
=
;

	call	l_glong
	ld	a,l
	and	%2
	ld	l,a
	ld	h,0
	ld	de,0
	ld	a,h
	or	l
	or	d
	or	e
	jp	%1	;%4
=
	ld	a,(hl)
	and	%2
	jp	%1	;%4

; 16 bit port operations
=
;

%title 16 bit out, remove redundant hl load
	ld	hl,%1	;const
	ld	a,l
	ld	bc,%2
	out	(c),a
	ld	hl,%3
=
	ld	a,%eval(%1 256 %%)
	ld	bc,%2
	out	(c),a
	ld	hl,%3


; Use stack less when we can
=
;

%title Stack load bypass push/pop cycle
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	push	de
	ld	hl,%1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	pop	de
=
	ld	e,(hl)
	inc	hl
	ld	d,(hl)
	ld	hl,%eval(%1 2 -)	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0

; Odd constructs observed in ping
=
;

%title Replace uint16_t global or with uint8_t -> de
	ld	hl,(_%1)
	ld	h,0
	ex	de,hl
	ld	hl,(_%2)
	ld	h,0
	call	l_or
	ex	de,hl
=
	ld	a,(_%1)
	ld	hl,_%2
	or	(hl)
	ld	e,a
	ld	d,0

%title Replace 16 bit or with 8 bit or -> de
	ld	e,a
	ld	d,0
	ld	hl,(_%1)
	ld	h,0
	call	l_or
	ex	de,hl
=
	ld	hl,_%1
	or	(hl)
	ld	e,a
	ld	d,0

%title Replace 16 bit or with 8 bit or -> hl
	ld	e,a
	ld	d,0
	ld	hl,(_%1)
	ld	h,0
	call	l_or
	ld	a,l
=
	ld	hl,_%1
	or	(hl)
	ld	l,a
	ld	h,0

%title Remove redundant load of char into hl
	ld	l,a
	ld	h,0
	and	a
	jp	%1z,%2	;%3
	ld	hl,%4
=
	and	a
	jp	%1z,%2	;%3
	ld	hl,%4

%title Load 8 bit value into integer
%notcpu 8085
	ld	l,(hl)
	ld	h,0
	pop	de
	call	l_pint
	ld	hl,%1	;const
=
	pop	de
	ex	de,hl
	ld	a,(de)
	ld	(hl),a
	inc	hl
	ld	(hl),0
	ld	hl,%1	;const

%title Redundant sign extend
	ld	a,l
	rla
	sbc	a
	ld	h,a
	pop	de
	ld	a,l
	ld	(de),a
	jp	%2	;EOS
=
	pop	de
	ld	a,l
	ld	(de),a
	jp	%2	;EOS

%title Cleanup tail int8 copy
	ld	l,(hl)
	pop	de
	ld	a,l
	ld	(de),a
	jp	%1	;EOS
=
	ld	a,(hl)
	pop	hl
	ld	(hl),a
	jp	%1	;EOS

%title Cleanup tail load and decrement
	ld	l,(hl)
	ld	h,0
	%"inc|dec"0	l
	jp	%1	;EOS
=
	jp	%1	;EOS

%title Tail int16 constant store
%check 0 <= %1 <= 255
	ld	(hl),%1
	inc	hl
	ld	(hl),%1
	jp	%2	;EOS
=
	ld	a,%1
	ld	(hl),a
	inc	hl
	ld	(hl),a
	jp	%2	;EOS

%title Needless push/pop cycle
	ld	l,(hl)
	ld	h,0
	push	hl
	pop	de
	pop	hl
=
	ld	e,(hl)
	ld	d,0
	pop	hl

%title 8 bit static addition
	ld	hl,(_%1)
	ld	h,0
	ex	de,hl
	ld	a,(_%2)
	add	e
	ld	(%3),a
	ld	hl,%4
=
	ld	hl,_%1
	ld	a,(_%2)
	add	(hl)
	ld	(%3),a
	ld	hl,%4

%title Pointless unsigned8 extension #1
	ld	h,0
	ld	a,l
	ld	(_%1),a
	ld	hl,%2
=
	ld	a,l
	ld	(_%1),a
	ld	hl,%2

%title Pointless unsigned8 extension #1
	ld	h,0
	ld	a,l
	ld	(_%1),a
	jp	%2	;EOS
=
	ld	a,l
	ld	(_%1),a
	jp	%2	;EOS

%title Repeated load of 8 bit #1
	ld	a,l
	ld	(de),a
	ld	a,l
=
	ld	a,l
	ld	(de),a

%title Repeated load of 8 bit #2
	ld	h,0
	ld	a,l
	ld	(_%1),a
	ld	h,0
	ld	a,l
=
	ld	a,l
	ld	(_%1),a

%title Setting a global buffer
%eval 1 = %5 %2 -
	ld	hl,_%1+%2
	ld	(hl),%3
	ld	hl,_%1+%5
	ld	(hl),%4
=
	ld	hl,_%1+%2
	ld	(hl),%3
	inc	hl
	ld	(hl),%4

%title Replace with 16 bit store
%notcpu gbz80
	ld	hl,_%1
	xor	a
	ld	(hl),a
	inc	hl
	ld	(hl),a
=
	ld	hl,0	;const
	ld	(_%1),hl

%title Signed char extension after truncation
	call	l_gchar
	ld	a,l
	and	%1
	ld	l,a
	ld	h,0
	call	l_sxt
=
	ld	a,(hl)
	and	%1
	ld	l,a
	ld	h,0

%title Save 8 bit and load address of it
	ld	(_%1),a
	ld	hl,_%1
=
	ld	hl,_%1
	ld	(hl),a

	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
	cp	%3
	scf
	jr	z,ASMPC+3
	ccf
	jp	c,%2
	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
=
	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
	cp	%3
	scf
	jr	z,ASMPC+3
	ccf
	jp	c,%2

%title Clean up setting bit in char
%notcpu 8080
%notcpu 8085
	push	hl
	call	l_gchar
	set	%1,l
	ld	a,l
	call	l_sxt
	pop	de
	ld	a,l
	ld	(de),a
.%2
	ld	hl,%3
=
	set	%1,(hl)
.%2
	ld	hl,%3

%title Pointless sign extension
	ld	a,%1
	call	l_sxt
	pop	de
	ld	a,l
	ld	(de),a
	jp	%2	;EOS
=
	ld	a,%1
	pop	de
	ld	(de),a
	jp	%2	;EOS

%title Remove negation, sign extension of char
	call	l_gchar
	call	l_neg
	ld	a,l
	call	l_sxt
	pop	de
	ld	a,l
	ld	(de),a
.%2
	ld	hl,%3
=
	ld	a,(hl)
	neg
	pop	de
	ld	(de),a
.%2
	ld	hl,%3

%title Pointless 16 bit load for jump
	ld	l,(hl)
	ld	h,0
	ld	a,l
	cp	%1
	jp	%2z,%3
	ld	hl,%4
=
	ld	a,(hl)
	cp	%1
	jp	%2z,%3
	ld	hl,%4

%title Testing sign bit of char
	call	l_gchar
	ld	a,l
	rla
	jp	%2c,%3
	ld	hl,%4
=
	ld	a,(hl)
	rla
	jp	%2c,%3
	ld	hl,%4

%title 8 bit logic being performed as 16 bit
	ld	e,(hl)
	ld	d,0
	ld	hl,%1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	call	l_%"and|xor|or"2
=
	ld	a,(hl)
	ld	hl,%1	;const
	add	hl,sp
	%2	(hl)
	ld	l,a
	ld	h,0

%title 8 bit addition/subtraction being performed as 16bit
%check -65535 <= %2 <= 65535
	ld	hl,(_%1)
	ld	h,0
	ld	bc,%2
	add	hl,bc
	ld	a,l
	ld	(_%1),a
	ld	hl,%3
=
	ld	hl,_%1
	ld	a,%eval(%2 256 %%)
	add	(hl)
	ld	(hl),a
	ld	hl,%3

%title Repeated logical operation
	and	%1
	ld	l,a
	ld	a,l
	and	%2
	ld	l,a
=
	and	%2
	ld	l,a

%title Redundant 8bit load into hl
	ld	l,a
	ld	h,0
	ld	(_%1),a
.%2
	ld	hl,%3
=
	ld	(_%1),a
.%2
	ld	hl,%3

%title Pointless 16bit load to store 8bit
	ld	hl,%1	;const
	ld	a,l
	ld	(_%2),a
	jp	%3	;EOS
=
	ld	a,%eval(%1 256 %%)
	ld	(_%2),a
	jp	%3	;EOS

%title Only load 8 bits rather than 16
	ld	hl,(_%1)
	ld	a,l
	ld	(_%2),a
	ld	hl,%3
=
	ld	a,(_%1)
	ld	(_%2),a
	ld	hl,%3

%title 16bit addition that should be 8 bit
%check -65535 <= %1 <= 65535
	ld	l,(hl)
	ld	h,0
	ld	bc,%1
	add	hl,bc
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%2
=
	ld	a,(hl)
	add	%eval(%1 256 %%)
	pop	de
	ld	(de),a
	ld	hl,%2

%title 16 bit addition, but only care about lower 8
%check -65535 <= %2 <= 65535
	ld	hl,(_%1)
	ld	bc,%2
	add	hl,bc
	ld	h,0
=
	ld	a,(_%1)
	add	%eval(%2 256 + 256 %%)
	ld	l,a
	ld	h,0

	ld	h,0
	%"inc|dec"1	hl
	ld	h,0
=
	%1	l
	ld	h,0

%title Pointless 8 bit extension at EOS
	ld	l,(hl)
	ld	h,0
	pop	de
	ld	a,l
	ld	(de),a
	jp	%1	;EOS
=
	ld	a,(hl)
	pop	de
	ld	(de),a
	jp	%1	;EOS

%title Sign extension, store drop
	ld	a,l
	call	l_sxt
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%1
=
	ld	a,l
	pop	de
	ld	(de),a
	ld	hl,%1

%title Repeatedly same value
	xor	a
	ld	(%1),a
	xor	a
=
	xor	a
	ld	(%1),a

%title Loading via l to store 8 bit
	ld	l,(hl)
	pop	de
	ld	a,l
	ld	(de),a
	ld	hl,%1
=
	ld	a,(hl)
	pop	de
	ld	(de),a
	ld	hl,%1

%title Redundant inc/decrement before load
	%"inc|dec"1	hl
	ld	hl,%2
=
	ld	hl,%2

%title Redundant h+l load before hl load
	ld	h,%1
	ld	l,%2
	ld	hl,%3
=
	ld	hl,%3

%title Add two longs together (21 -> 18b)
	push	hl
	call	l_glong2sp
	ld	hl,%1	;const
	add	hl,sp
	call	l_glong
	call	l_long_add
	pop	bc
	call	l_plong
	ld	hl,%2
=
	ex	de,hl
	ld	hl,%eval(%1 6 -)	;const
	add	hl,sp
	ex	de,hl
	ld	b,4
.i_o%N
	ld	a,(de)
	adc	(hl)
	ld	(hl),a
	inc	hl
	inc	de
	djnz	i_o%N
	ld	hl,%2

%title Logical x |= y; x &= y; x ^= y; (21 -> 18b)
	push	hl
	call	l_glong2sp
	ld	hl,%1	;const
	add	hl,sp
	call	l_glong
	call	l_long_%"or|xor|and"3
	pop	bc
	call	l_plong
	ld	hl,%2
=
	ex	de,hl
	ld	hl,%eval(%1 6 -)	;const
	add	hl,sp
	ex	de,hl
	ld	b,4
.i_o%N
	ld	a,(de)
	%3	(hl)
	ld	(hl),a
	inc	hl
	inc	de
	djnz	i_o%N
	ld	hl,%2

%title uint8_t global logic
%check -255 <= %3 <= 255
	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	%2	%3
	ld	l,a
	ld	h,0
=
	ld	a,(_%1)
	%2	%3
	ld	l,a
	ld	h,0

%title uint8_t global logic
	ld	h,0
	ex	de,hl
	ld	hl,(_%1)
	ld	h,0
	call	l_%"or|xor|and"2
=
	ld	h,0
	ld	a,(_%1)
	%2	l
	ld	l,a

%title uint8_t register bouncing
%check -255 <= %3 <= 255
	ld	l,a
	ld	a,l
	%2	%3
	ld	l,a
=
	%2	%3
	ld	l,a

%title uint8_t register bouncing + check
	and	%1
	ld	l,a
	ld	a,l
	and	a
=
	and	%1
	ld	l,a

%title int32 store + redundant load
	ld	(_%1),hl
	ld	(_%1+2),de
	ld	hl,(_%1)
	ld	de,(_%1+2)
=
	ld	(_%1),hl
	ld	(_%1+2),de

%title memcpy return value not needed
	push	de
	ld	bc,%0
	ldir
	pop	hl
	ld	hl,%1
=
	ld	bc,%0
	ldir
	ld	hl,%1

%title Push/pop around ex
	push	hl
	ex	de,hl
	pop	de
=
	ex	de,hl

%title Redundant 16 bit constant load
	ld	hl,%1	;const
	ld	a,l
	ld	(_%2),a
.%3
	ld	hl,%4
=
	ld	a,%eval(%1 256 %%)
	ld	(_%2),a
.%3
	ld	hl,%4

%title Bit test after 16 bit load
	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	and	%2
	jp	%3
	ld	hl,%4
=
	ld	a,(_%1)
	and	%2
	jp	%3
	ld	hl,%4

	ld	hl,_%1
	inc	h
=
	ld	hl,_%1 + 256

	ld	hl,(_%1)
	ld	h,0
	ld	a,h
	or	l
	jp	%2,%3	;EOS
.%4
	ld	hl,%5
=
	ld	a,(_%1)
	and	a
	jp	%2,%3	;EOS
.%4
	ld	hl,%5

%title Eliminate redundant load of a
	ld	a,%1
	cp	%2
	jp	%3,%4	;%5
	ld	a,(%1)
=
	ld	a,%1
	cp	%2
	jp	%3,%4	;%5

%title Eliminate jp over ret (z)
	jp	z,%1	;%2
	ret


.%1
=
	ret	nz
.%1

	ld	a,h
	or	l
	ret	%1
.%2
	ret
=
.%2
	ret

%title Pointless clearing top byte
	ld	h,0
	ld	a,%1
	sub	%2
	jp	%3c,%5	;
	ld	hl,%8	;const
	jr	%6
.%5
	ld	hl,%7	;const
=
	ld	a,%1
	sub	%2
	jp	%3c,%5	;
	ld	hl,%8	;const
	jr	%6
.%5
	ld	hl,%7	;const

%title Store uint8 inline rather than extend
	ld	hl,(_%1)
	ld	h,0
	call	l_pint
	jp	%2	;EOS
=
	ld	a,(_%1)
	ld	(de),a
	jp	%2	;EOS

%title Use 8 bit load for comparison
	ld	hl,(_%1)
	ld	h,0
	ld	a,l
	cp	%2
	jp	z,%3	;%4
	ld	hl,%5
=
	ld	a,(_%1)
	cp	%2
	jp	z,%3	;%4
	ld	hl,%5

%title Remove jump over
	jp	nz,%1
	jr	%2
.%1
=
	jr	z,%2
.%1

	ld	a,(_%1)
	cp	%2
	jp	%3	;
	ld	a,(_%1)
=
	ld	a,(_%1)
	cp	%2
	jp	%3	;

%title Simplify char comparison
	scf
	jr	z,ASMPC+3
	ccf
	jp	c,%1	;%2
=
	jp	z,%1	;%2

%title Remove dangling jp
	ret


	jp	%1	;EOS
=
	ret

%title Trailing statement increment uchar
	ld	hl,(_%1)
	ld	h,0
	inc	hl
	ld	a,l
	ld	(_%1),a
	jp	%2	;EOS
=
	ld	hl,_%1
	inc	(hl)
	jp	%2	;EOS

%title Assign uchar from stack variable
	call	l_gint	;
	ld	a,l
	ld	(_%1),a
	jp	%2	;EOS
=
	ld	a,(hl)
	ld	(_%1),a
	jp	%2	;EOS

%title Tidy up logic
	ld	hl,1	;const
	jr	%2
.%3
	ld	hl,0	;const
.%2
	ld	a,h
	or	l
	jr	z,%5
.%6
	ld	hl,1	;const
.%5
=
.%6
	ld	hl,1	;const
	jr	%5
.%3
	ld	hl,0	;const
.%5

%title Redundant hl load
	ld	l,(hl)
	ld	h,0
	ld	a,l
	ld	(_%1),a
.%2
	ld	hl,%3
=
	ld	a,(hl)
	ld	(_%1),a
.%2
	ld	hl,%3

%title remove redundant hl load at EOS
	ld	l,(hl)
	ld	a,l
	ld	(_%1),a
	jp	%2	;EOS
=
	ld	a,(hl)
	ld	(_%1),a
	jp	%2	;EOS

%title Redundant uchar extension
	ld	h,0
	ld	a,l
	sub	%1
	jp	%2
	ld	hl,%3
=
	ld	a,l
	sub	%1
	jp	%2
	ld	hl,%3

%title Remove forced uchar conversion of true/false
	ld	hl,1	;const
	jr	%2
.%3
	ld	hl,0	;const
.%2
	ld	h,0
	ret
=
	ld	hl,1	;const
	ret
.%3
	ld	hl,0	;const
	ret

%title Redundant push around load of static uint8
	push	de
	ld	hl,(_%1)
	ld	h,0
	pop	de
=
	ld	hl,(_%1)
	ld	h,0

%title Increment memory not via hl
	ld	hl,(_%1)
	ld	h,0
	%2c	hl
	ld	a,l
	ld	(_%1),a
.i_%3
	ld	hl,%4
=
	ld	hl,_%1
	%2c	(hl)
.i_%3
	ld	hl,%4

%title Redundant sign extnsion
	ld	l,(hl)
	ld	h,0
	call	l_%"xor|and|or"2
	ld	a,l
	call	l_sxt
	pop	de
	ld	a,l
	ld	(de),a
=
	ld	a,(hl)
	%2	e
	pop	de
	ld	(de),a

	ld	hl,(_%1)
	ld	h,0
	ex	de,hl
	ld	hl,(_%2)
	ld	h,0
	ex	de,hl
	and	a
	sbc	hl,de
	jp	%3c,%4	;
	ld	hl,%5
=
	ld	hl,(_%2)
	ld	a,(_%1)
	sub	l
	jp	%3c,%4	;
	ld	hl,%5

%notcpu gbz80
	pop	bc
	ld	hl,%1
	push	hl
	call	_%2
=
	ld	hl,%1
	ex	(sp),hl
	call	_%2

	ld	l,(hl)
	ld	h,0
	ld	bc,%1
	add	hl,bc
	ld	a,l
	pop	de
	ld	(de),a
	ld	hl,%2
=
	ld	a,(hl)
	add	%eval(%1 256 + 256 %%)
	pop	de
	ld	(de),a
	ld	hl,%2

%eval 1 = %3 %1 -
	ld	hl,%1	;const
	add	hl,sp
	ld	(hl),%2
	ld	hl,%3	;const
	add	hl,sp
=
	ld	hl,%1	;const
	add	hl,sp
	ld	(hl),%2
	inc	hl

%eval 2 = %3 %1 -
	ld	hl,%1	;const
	add	hl,sp
	ld	(hl),%2
	ld	hl,%3	;const
	add	hl,sp
=
	ld	hl,%1	;const
	add	hl,sp
	ld	(hl),%2
	inc	hl
	inc	hl

	ld	hl,(_%1)
	ld	h,0
	ld	a,h
	or	l
	jp	%2,%3	;EOS
=
	ld	a,(_%1)
	and	a
	jp	%2,%3	;EOS


%check 0 <= %1 <= 255
%check 0 <= %2 <= 255
	ld	hl,%1	;const
	push	hl
	ld	hl,%2	;const
=
	ld	hl,%1	;const
	push	hl
	ld	l,%2

	push	hl
	ld	hl,(_%1)
	ld	h,0
	add	hl,hl
	pop	de
	add	hl,de
=
	ex	de,hl
	ld	hl,(_%1)
	ld	h,0
	add	hl,hl
	add	hl,de

	call	l_gchar
	pop	de
	ld	a,l
	ld	(de),a
.%1
	ld	hl,%2
=
	ld	a,(hl)
	pop	de
	ld	(de),a
.%1
	ld	hl,%2

%notcpu gbz80
	ld	hl,_%1
	inc	(hl)
	ld	a,(hl)
	inc	hl
	jr	nz,ASMPC+3
	inc	(hl)
	jp	%2	;EOS
=
	ld	hl,(_%1)
	inc	hl
	ld	(_%1),hl
	jp	%2	;EOS

%notcpu gbz80
	ld	hl,_%1
	inc	(hl)
	ld	a,(hl)
	inc	hl
	jr	nz,ASMPC+3
	inc	(hl)
	ld	hl,%2
=
	ld	hl,(_%1)
	inc	hl
	ld	(_%1),hl
	ld	hl,%2

%notcpu gbz80
	ld	hl,_%1
	dec	(hl)
	ld	a,(hl)
	inc	hl
	cp	255
	jr	nz,ASMPC+3
	dec	(hl)
	ld	hl,%2
=
	ld	hl,(_%1)
	dec	hl
	ld	(_%1),hl
	ld	hl,%2

%notcpu gbz80
	ld	hl,_%1
	dec	(hl)
	ld	a,(hl)
	inc	hl
	cp	255
	jr	nz,ASMPC+3
	dec	(hl)
	ld	h,(hl)
	ld	l,a
=
	ld	hl,(_%1)
	dec	hl
	ld	(_%1),hl

%check 0 <= %2 <= 65535
%check 0 <= %3 <= 65535
	add	hl,%2
	add	hl,%3
=
	add	hl,%eval(%2 %3 +)

%check 0 <= %2 <= 65535
	ld	hl,_%1
	add	hl,%2
=
	ld	hl,_%1+%2

%check 0 <= %1 <= 255
	ld	l,(hl)
	ld	h,0
	ld	de,%1
	and	a
	sbc	hl,de
	jp	nz,%3	;
	ld	hl,%4
=
	ld	a,(hl)
	cp	%1
	jp	nz,%3	;
	ld	hl,%4

%check 0 <= %1 <= 255
	pop	hl
	push	hl
	ld	l,h
	ld	h,0
	ld	de,%1
	and	a
	sbc	hl,de
	jp	nz,%3	;
	add	hl,sp
=
	ld	hl,1	;const
	add	hl,sp
	ld	a,(hl)
	cp	%1
	jp	nz,%3	;
	ld	hl,0	;const
	add	hl,sp

	pop	hl
	push	hl
	ld	l,h
	ld	h,0
	ld	a,h
	or	l
	jp	%2,%3	;
	ld	hl,%4
=
	ld	hl,1	;const
	add	hl,sp
	ld	a,(hl)
	and	a
	jp	%2,%3	;
	ld	hl,%4

%check 0 <= %2 <= 255
	ld	hl,(_%1)
	ld	h,0
	ld	de,%2
	and	a
	sbc	hl,de
	jp	z,%3	;
=
	ld	a,(_%1)
	cp	%2
	jp	z,%3	;

%title Kill redundant upper 8 cleaning (14b -> 12b)
	ld	hl,%1
	ld	h,0
	ld	a,%2
	sub	l
	jp	%3c,%4
	ld	hl,%5
=
	ld	hl,%1
	ld	a,%2
	sub	l
	jp	%3c,%4
	ld	hl,%5

%title Inline sint8 -> sint16 can be extended to sint32
	ld	a,l
	rla
	sbc	a
	ld	h,a
	call	l_int2long_s
=
	ld	a,l
	rla
	sbc	a
	ld	h,a
	ld	d,a
	ld	e,a

%title Redundant h,0 removed
	ld	h,0
	ld	a,l
	and	a
	jp	%2z,%3
	ld	hl,%4
=
	ld	a,l
	and	a
	jp	%2z,%3
	ld	hl,%4

%title Redundant swap
	ld	l,h
	ld	a,l
	and	a
	jp	%1,%2	;
	ld	hl,%3
=
	ld	a,h
	and	a
	jp	%1,%2	;
	ld	hl,%3

	ld	a,l
	ld	(%1),a
	ld	a,l
=
	ld	a,l
	ld	(%1),a

%title De-dupe labels
%eval 0 = %2 %1 - !
.i_%1
.i_%2
=
%activate
.i_%1
.i_%2
=
%once
.i_%2
%activate
; --- Start of Optimiser additions ---
=
%once
; --- Start of Optimiser additions ---
	defc	i_%1 = i_%2

%title Jump to ret
.i_%1
	ret
=
%activate
	j%"p|r"	i_%1	;%%2
=
	ret
%activate
	j%"p|r"	%%2,i_%1	;%%3
=
	ret	%%2

%title Moved from z80rules.0, structure setting
%check 0 <= %1 <= 65535
%check 0 <= %3 <= 65535
	pop	hl
	push	hl
	ld	bc,%1
	add	hl,bc
	ld	(hl),%2
	inc	hl
	ld	(hl),%4
	pop	hl
	push	hl
	ld	bc,%3
	add	hl,bc
=
	pop	hl
	push	hl
	ld	bc,%1
	add	hl,bc
	ld	(hl),%2
	inc	hl
	ld	(hl),%4
	ld	bc,%eval(%3 %1 - 1 -)
	add	hl,bc

%title Moved from z80rules.0, structure setting
%check 0 <= %1 <= 65535
%check 0 <= %3 <= 65535
	pop	hl
	push	hl
	ld	bc,%1
	add	hl,bc
	ld	(hl),%2
	pop	hl
	push	hl
	ld	bc,%3
	add	hl,bc
=
	pop	hl
	push	hl
	ld	bc,%1
	add	hl,bc
	ld	(hl),%2
	ld	bc,%eval(%3 %1 -)
	add	hl,bc

%title moved from z80rules.0 inc/dec
%notcpu gbz80
	ld	hl,_%1
	push	hl
	call	l_gint	;%2
	%3c	hl
	pop	de
	call	l_pint
=
	ld	hl,(_%1)
	%3c	hl
	ld	(_%1),hl

%title Moved from z80rules.0 static uint8_t inc/dec
	ld	hl,(_%1)
	ld	h,0
	%2c	hl
	ld	a,l
	ld	(_%1),hl
	ld	hl,%3
=
	ld	hl,_%1
	%2c	hl
	ld	hl,%3

%title Moved from z80rules.0, redundant uint8 load
	ld	l,(hl)
	ld	h,0
	ld	hl,%1
=
	ld	hl,%1

%title Moved from z80rules.0 optimise 8 bit increment
	ld	hl,(%1)
	ld	h,0
	%3c	hl
	ld	a,l
	ld	(%1),a
	ld	hl,%2
=
	ld	hl,%1
	%3c	(hl)
	ld	hl,%2

%notcpu 8085
%notcpu r2ka
%notcpu r3k
	inc	hl
	inc	hl
	inc	hl
	call	l_gint	;
=
	call	l_gint3	;

%notcpu 8085
%notcpu r2ka
%notcpu r3k
	inc	hl
	inc	hl
	call	l_gint	;
=
	call	l_gint2	;

%notcpu 8085
%notcpu r2ka
%notcpu r3k
	inc	hl
	call	l_gint	;
=
	call	l_gint1	;

%notcpu 8085
%notcpu r2ka
%notcpu r3k
%notcpu kc160
%check 4 <= %1 <= 8
	ld	bc,%1
	add	hl,bc
	call	l_gint	;
=
	call	l_gint%1	;

%notcpu 8085
%notcpu r2ka
%notcpu r3k
%notcpu kc160
%notcpu gbz80
%check 1 <= %1 <= 8
	ld	hl,%1	;const
	add	hl,sp
	call	l_gint	;
=
	call	l_gint%1sp	;

%notcpu 8085
%notcpu r2ka
%notcpu r3k
%notcpu kc160
	inc	hl
	inc	hl
	inc	hl
	call	l_gchar
=
	call	l_gchar3

%notcpu 8085
%notcpu r2ka
%notcpu r3k
%notcpu kc160
	inc	hl
	inc	hl
	call	l_gchar
=
	call	l_gchar2

%notcpu 8085
%notcpu r2ka
%notcpu r3k
%notcpu kc160
	inc	hl
	call	l_gchar
=
	call	l_gchar1

%notcpu 8085
%notcpu r2ka
%notcpu r3k
%notcpu kc160
%check 4 <= %1 <= 8
	ld	bc,%1
	add	hl,bc
	call	l_gchar
=
	call	l_gchar%1

%title Truncating long
	call	l_glong
	ex	de,hl
	ld	hl,%1	;const
	push	de
	ex	de,hl
	ld	hl,%2	;const
=
	call	l_gint
	push	hl
	ld	de,%1	;const
	ld	hl,%2	;const

%title Reverse primary/secondary load
%check 4 <= %2 <= 8
	ld	hl,%1	;const
	push	hl
	call	l_gint%2sp	;
	pop	de
=
	call	l_gint%eval(%2 2-)sp	;
	ld	de,%1

%title Optimise secondary load (perf)
	ld	hl,(_%1)	X
	ld	h,0
	ex	de,hl
	ld	hl,%2	;const
=
	ld	a,(_%1)
	ld	e,a
	ld	d,0
	ld	hl,%2	;const

%title Use 8 bit addition
%check 0 <= %2 <= 256
	ld	hl,(_%1)
	ld	h,0
	ld	bc,%2
	add	hl,bc
	ld	h,0
=
	ld	a,(_%1)
	add	%eval(%2 256 + 256 %%)
	ld	l,a
	ld	h,0

%title Load directly into a rather than via hl
	ld	hl,_%1
	ld	a,(hl)
	pop	de
	ld	(de),a
	ld	hl,%2
=
	ld	a,(_%1)
	pop	de
	ld	(de),a
	ld	hl,%2

	ld	hl,_%1
	ld	a,(hl)
	pop	de
	ld	(de),a
	ld	l,a
=
	ld	a,(_%1)
	pop	de
	ld	(de),a
	ld	l,a

%notcpu gbz80
	push	hl
	ld	a,%1
	pop	de
=
	ex	de,hl
	ld	a,%1

%title Remove redundant ld h,0
	ld	h,0
	ld	bc,%1
	add	hl,bc
	ld	h,0
=
	ld	bc,%1
	add	hl,bc
	ld	h,0

%title Tidy up function tail
	pop	bc
	ld	hl,%1	;const
	add	hl,sp
	ld	sp,hl
	ret
=
	ld	hl,%eval(%1 2 +)	;const
	add	hl,sp
	ld	sp,hl
	ret

%title Better sdccdecl handling 1
	ld	h,0
	ld	b,l
	push	bc
	inc	sp
	ld	hl,%1
=
	ld	a,l
	push	af
	inc	sp
	ld	hl,%1

%title Better sdccdecl handling - global
	ld	hl,(_%1)
	ld	a,l
	push	af
	inc	sp
	ld	hl,%2
=
	ld	a,(_%1)
	push	af
	inc	sp
	ld	hl,%2

%title Better sdccdecl handling - local
	ld	l,(hl)
	ld	a,l
	push	af
	inc	sp
	ld	hl,%2
=
	ld	a,(hl)
	push	af
	inc	sp
	ld	hl,%2


%title Better sdccdecl handling - local 2
%eval 2 = %2 %1 -
	ld	hl,%1	;const
	add	hl,sp
	ld	a,(hl)
	push	af
	inc	sp
	ld	hl,%2	;const
	add	hl,sp
	ld	a,(hl)
	push	af
	inc	sp
	ld	hl,%3
=
	ld	hl,%1	;const
	add	hl,sp
	ld	d,(hl)
	inc	hl
	ld	e,(hl)
	push	de
	ld	hl,%3

%title Char parameter passing
%eval 3 = %2 %1 -
	ld	hl,%1	;const
	add	hl,sp
	ld	l,(hl)
	ld	h,0
	push	hl
	ld	hl,%2	;const
	add	hl,sp
=
	ld	hl,%1	;const
	add	hl,sp
	ld	c,(hl)
	ld	b,0
	push	bc
	inc	hl
