Index: ChangeLog
===================================================================
--- ChangeLog	(revision 13131)
+++ ChangeLog	(working copy)
@@ -1,3 +1,53 @@
+2022-07-22 Philipp Klaus Krause <krauseph AT informatik.uni-freiburg.de>
+
+	* src/SDCCast.c,
+	  support/regression/tests/bug-3401.c:
+	  Fix bug #3401.
+
+2022-07-19 Philipp Klaus Krause <krauseph AT informatik.uni-freiburg.de>
+
+	* src/z80/gen.c,
+	  support/regression/tests/bug-3461.c:
+	  Fix bug #3461.
+
+2022-07-18 Philipp Klaus Krause <krauseph AT informatik.uni-freiburg.de>
+
+	* src/z80/gen.c:
+	  Partial fix for bug #3461.
+
+2022-07-11 Philipp Klaus Krause <krauseph AT informatik.uni-freiburg.de>
+
+	* src/z80/gen.c,
+	  support/regression/tests/bug-3456.c:
+	  Fix bug #3456.
+
+2022-06-25 Philipp Klaus Krause <krauseph AT informatik.uni-freiburg.de>
+
+	* src/z80/gen.c,
+	  support/regression/tests/bug-3458.c.in:
+	  Fix bug #3458.
+
+2022-06-01 Philipp Klaus Krause <krauseph AT informatik.uni-freiburg.de>
+
+	* src/z80/gen.c,
+	  support/regression/tests/bug-3406.c:
+	  Fix bug #3406.
+
+2022-06-01 Philipp Klaus Krause <krauseph AT informatik.uni-freiburg.de>
+
+	* src/SDCCast.c:
+	  Add an assertion to show the underlying issue of bug #3401.
+
+2022-05-15 Philipp Klaus Krause <krauseph AT informatik.uni-freiburg.de>
+
+	* src/z80/gen.c:
+	  Fix bug #3388.
+
+2022-03-28 Philipp Klaus Krause <krauseph AT informatik.uni-freiburg.de>
+
+	* src/z80/ralloc2.cc:
+	  Fix code generation issues in use of iy.
+
 2022-02-26 Philipp Klaus Krause <krauseph@informatik.uni-freiburg.de>
 
 	* src/SDCCsymt.c,
@@ -48206,4 +48256,4 @@
 	* as/mcs51/lklex.c:  accept everything as symbol name in rel-files, bug fix ID 452601
 	* as/mcs51/lksym.c:  accept everything as symbol name in rel-files, bug fix ID 452601
 
-$Revision: 13081 $
+$Revision: 13131 $
Index: src/SDCCasm.c
===================================================================
--- src/SDCCasm.c	(revision 13131)
+++ src/SDCCasm.c	(working copy)
@@ -403,8 +403,8 @@
 static const ASM_MAPPING _asxxxx_mapping[] = {
   {"labeldef", "%s::"},
   {"slabeldef", "%s:"},
-  {"tlabeldef", "%05d$:"},
-  {"tlabel", "%05d$"},
+  {"tlabeldef", "l%N_%05d$:"},
+  {"tlabel", "l%N_%05d$"},
   {"immed", "#"},
   {"zero", "#0x00"},
   {"one", "#0x01"},
@@ -427,6 +427,7 @@
   {"msbimmeds", "#>(%s)"},
   {"module", ".module %s"},
   {"global", ".globl %s"},
+  {"extern", ".globl %s"},
   {"fileprelude", ""},
   {"functionheader",
    "; ---------------------------------\n"
Index: src/SDCCast.c
===================================================================
--- src/SDCCast.c	(revision 13131)
+++ src/SDCCast.c	(working copy)
@@ -4060,10 +4060,11 @@
       if (reduceTypeAllowed &&
           IS_LITERAL (RTYPE (tree)) &&
           IS_BOOLEAN (LTYPE (tree)) &&
-          IS_INTEGRAL (RTYPE (tree)) &&
+          IS_AST_LIT_VALUE (tree->right) &&
           resultType == RESULT_TYPE_BOOL &&
           tree->opval.op == '^')   /* the same source is used by 'bitwise or' */
         {
+          wassert (tree->right->type == EX_VALUE);
           unsigned long litval = AST_ULONG_VALUE (tree->right);
           if (litval == 0 || litval == 1)
             {
@@ -4077,15 +4078,16 @@
               return decorateType (tree, resultType, reduceTypeAllowed);
             }
         }
-        
+
       /* OR / XOR char with literal integral, try to reduce integral to CHAR if it fits in a CHAR */
       if (reduceTypeAllowed && 
           !TARGET_PDK_LIKE && // Temporary fix to avoid bug #3259 - Wrong opcodes
           IS_LITERAL (RTYPE (tree)) &&
-          IS_INTEGRAL (RTYPE (tree)) &&
+          IS_AST_LIT_VALUE (tree->right) &&
           !IS_CHAR (RTYPE (tree)) &&
           IS_CHAR(LTYPE(tree)))
         {
+          wassert (tree->right->type == EX_VALUE);
           unsigned long litval = AST_ULONG_VALUE (tree->right); 
           if ((litval >= 0) && (litval <= 255) && reduceTypeAllowed)
             {
Index: src/SDCCgen.c
===================================================================
--- src/SDCCgen.c	(revision 13131)
+++ src/SDCCgen.c	(working copy)
@@ -230,13 +230,17 @@
           break;
 
         case ':':
-          /* Add \n for labels, not dirs such as c:\mydir */
-          if (!inComment && !inLiteral && !inLiteralString && (isspace ((unsigned char) bp[1])))
+          /* Add \n for labels, not dirs such as c:\mydir, not local direct assignment =: */
+          if (!inComment && !inLiteral && !inLiteralString && (isspace ((unsigned char) bp[1])) && (*(bp-1) != '='))
             {
               ++bp;
               *bp = '\0';
               ++bp;
+              /* Don't emit leading whitespaces */
+              while (isspace (*begin))
+                ++begin;
               emitcode (begin, NULL);
+              genLine.lineCurr->isLabel = 1;
               begin = bp;
             }
           else
Index: src/SDCCglue.c
===================================================================
--- src/SDCCglue.c	(revision 13131)
+++ src/SDCCglue.c	(working copy)
@@ -195,7 +195,7 @@
            (sym->_isparm && !IS_REGPARM (sym->etype) && !IS_STATIC (sym->localof->etype))) &&
           addPublics &&
           !IS_STATIC (sym->etype) &&
-          (IS_FUNC (sym->type) ? (sym->used || IFFUNC_HASBODY (sym->type)) : (!IS_EXTERN (sym->etype) || sym->ival)) &&
+          (IS_FUNC (sym->type) ? (IFFUNC_HASBODY (sym->type)) : (!IS_EXTERN (sym->etype) || sym->ival)) &&
           !(IFFUNC_ISINLINE (sym->type) && !IS_STATIC (sym->etype) && !IS_EXTERN (sym->etype)))
         {
           addSetHead (&publics, sym);
@@ -371,11 +371,15 @@
               emitDebugSym (&map->oBuf, sym);
               dbuf_printf (&map->oBuf, "==.\n");
             }
-          if (IS_STATIC (sym->etype) || sym->level)
-            dbuf_tprintf (&map->oBuf, "!slabeldef\n", sym->rname);
-          else
-            dbuf_tprintf (&map->oBuf, "!labeldef\n", sym->rname);
-          dbuf_tprintf (&map->oBuf, "\t!ds\n", (unsigned int) size & 0xffff);
+          if (!IS_EXTERN (sym->etype))
+            {
+              if (IS_STATIC (sym->etype) || sym->level)
+                dbuf_tprintf (&map->oBuf, "!slabeldef\n", sym->rname);
+              else
+                dbuf_tprintf (&map->oBuf, "!labeldef\n", sym->rname);
+
+              dbuf_tprintf (&map->oBuf, "\t!ds\n", (unsigned int) size & 0xffff);
+            }
         }
 
       sym->ival = NULL;
@@ -1899,9 +1903,12 @@
   /* for all variables in this segment do */
   for (sym = setFirstItem (map->syms); sym; sym = setNextItem (map->syms))
     {
-      /* if it is "extern" then do nothing */
+      /* if it is "extern" then add to the extern table */
       if (IS_EXTERN (sym->etype) && !sym->ival)
-        continue;
+        {
+          addSetHead (&externs, sym);
+          continue;
+        }
 
       /* eliminate redundant __str_%d (generated in stringToSymbol(), SDCCast.c) */
       if (!isinSet (tmpSet, sym))
@@ -2079,7 +2086,11 @@
 void
 flushStatics (void)
 {
+  if (options.const_seg)
+      dbuf_tprintf (&code->oBuf, "\t!area\n", options.const_seg);
   emitStaticSeg (statsg, codeOutBuf);
+  if (options.const_seg)
+      dbuf_tprintf(&code->oBuf, "\t!areacode\n", options.code_seg);
   statsg->syms = NULL;
 }
 
Index: src/SDCCmain.c
===================================================================
--- src/SDCCmain.c	(revision 13131)
+++ src/SDCCmain.c	(working copy)
@@ -519,18 +519,15 @@
 void
 printVersionInfo (FILE * stream)
 {
-  int i;
-
-  fprintf (stream, "SDCC : ");
-  for (i = 0; i < NUM_PORTS; i++)
-    fprintf (stream, "%s%s", i == 0 ? "" : "/", _ports[i]->target);
-
-  fprintf (stream, " " SDCC_VERSION_STR
+  fprintf(stream, "\nZSDCC IS A MODIFICATION OF SDCC FOR Z88DK\n");
+  fprintf(stream, "Build: " SDCC_VERSION_STR
 #ifdef SDCC_SUB_VERSION_STR
-           "/" SDCC_SUB_VERSION_STR
+    "/" SDCC_SUB_VERSION_STR
 #endif
-           " #%s (%s)\n", getBuildNumber (), getBuildEnvironment ());
-  fprintf (stream, "published under GNU General Public License (GPL)\n");
+    " #%s (%s) " __DATE__ "\n\n", getBuildNumber(), getBuildEnvironment());
+  fprintf(stream, "sdcc website:\nhttps://sourceforge.net/projects/sdcc/\n\n");
+  fprintf(stream, "patch details:\nhttps://github.com/z88dk/z88dk/blob/master/src/zsdcc/sdcc-z88dk.patch\n\n");
+  fprintf(stream, "published under GNU General Public License (GPL)\n");
 }
 
 static void
Index: src/SDCCopt.c
===================================================================
--- src/SDCCopt.c	(revision 13131)
+++ src/SDCCopt.c	(working copy)
@@ -1016,7 +1016,7 @@
       /* TODO: Eliminate it, convert any SEND of volatile into DUMMY_READ_VOLATILE. */
       /* For now just convert back to call to make sure any volatiles are read. */
 
-      strcpy(OP_SYMBOL (IC_LEFT (icc))->rname, !strcmp (bif->name, "__builtin_memcpy") ? "___memcpy" : (!strcmp (bif->name, "__builtin_strncpy") ? "_strncpy" : "_memset"));
+      strcpy(OP_SYMBOL (IC_LEFT (icc))->rname, !strcmp (bif->name, "__builtin_memcpy") ? "_memcpy" : (!strcmp (bif->name, "__builtin_strncpy") ? "_strncpy" : "_memset"));
       goto convert;
     }
 
@@ -1026,7 +1026,7 @@
       if (bitVectIsZero (OP_USES (IC_RESULT (icc))) && (IS_OP_LITERAL (IC_LEFT (lastparam)) || !strcmp (bif->name, "__builtin_memcpy")))
         return;
 
-      strcpy(OP_SYMBOL (IC_LEFT (icc))->rname, !strcmp (bif->name, "__builtin_memcpy") ? "___memcpy" : (!strcmp (bif->name, "__builtin_strncpy") ? "_strncpy" : "_memset"));
+      strcpy(OP_SYMBOL (IC_LEFT (icc))->rname, !strcmp (bif->name, "__builtin_memcpy") ? "_memcpy" : (!strcmp (bif->name, "__builtin_strncpy") ? "_strncpy" : "_memset"));
       goto convert;
     }
 
@@ -2166,10 +2166,11 @@
   int i;
   int change = 0;
   iCode *ic, *newic;
-  iCode *uic, *skipuic;
+  iCode *uic, *lic, *ric, *skipuic;
   sym_link *nextresulttype;
   symbol *sym;
   int resultsize, nextresultsize;
+  unsigned long litval;
 
   // Wide loop counter
   for (i = 0; i < count; i++)
@@ -2366,8 +2367,8 @@
               continue;
             }
 
-          iCode *lic = IS_ITEMP (left) ? hTabItemWithKey (iCodehTab, bitVectFirstBit (OP_DEFS (left))) : 0;
-          iCode *ric = IS_ITEMP (right) ? hTabItemWithKey (iCodehTab, bitVectFirstBit (OP_DEFS (right))) : 0;
+          lic = IS_ITEMP (left) ? hTabItemWithKey (iCodehTab, bitVectFirstBit (OP_DEFS (left))) : 0;
+          ric = IS_ITEMP (right) ? hTabItemWithKey (iCodehTab, bitVectFirstBit (OP_DEFS (right))) : 0;
 
           if (lic)
             {
@@ -2374,7 +2375,7 @@
               if (lic->op != BITWISEAND || !IS_OP_LITERAL (IC_LEFT (lic)) && !IS_OP_LITERAL (IC_RIGHT (lic)))
                 continue;
 
-              unsigned long litval = operandLitValue (IS_OP_LITERAL (IC_LEFT (lic)) ? IC_LEFT (lic) : IC_RIGHT (lic));
+              litval = operandLitValue (IS_OP_LITERAL (IC_LEFT (lic)) ? IC_LEFT (lic) : IC_RIGHT (lic));
 
               if (litval > 0x7f)
                 continue;
@@ -2387,7 +2388,7 @@
               if (ric->op != BITWISEAND || !IS_OP_LITERAL (IC_LEFT (ric)) && !IS_OP_LITERAL (IC_RIGHT (ric)))
                 continue;
 
-              unsigned long litval = operandLitValue (IS_OP_LITERAL (IC_LEFT (ric)) ? IC_LEFT (ric) : IC_RIGHT (ric));
+              litval = operandLitValue (IS_OP_LITERAL (IC_LEFT (ric)) ? IC_LEFT (ric) : IC_RIGHT (ric));
 
               if (litval > 0x7f)
                 continue;
Index: src/z80/gen.c
===================================================================
--- src/z80/gen.c	(revision 13131)
+++ src/z80/gen.c	(working copy)
@@ -1460,6 +1460,7 @@
           sym->aop = aop = newAsmop (AOP_STK);
         }
 
+      memset (aop->regs, -1, sizeof(aop->regs));
       aop->size = getSize (sym->type);
       aop->aopu.aop_stk = sym->stack;
       return aop;
@@ -1578,7 +1579,7 @@
   else
     {
       aop = newAsmop (AOP_IMMD);
-      
+
       dbuf_init (&dbuf, 128);
       if (val)
         {
@@ -1862,6 +1863,7 @@
   /* must be in a register */
   sym->aop = op->aop = aop = newAsmop (AOP_REG);
   aop->size = sym->nRegs;
+  memset (aop->regs, -1, sizeof(aop->regs));
   for (i = 0; i < sym->nRegs; i++)
     {
       wassertl (sym->regs[i], "Symbol in register, but no register assigned.");
@@ -1890,6 +1892,7 @@
         return (IS_SM83 ? ASMOP_E : ASMOP_L);
       case 2:
         return (IS_SM83 ? ASMOP_DE : ASMOP_HL);
+      case 3:
       case 4:
         return (IS_SM83 ? ASMOP_HLDE : ASMOP_DEHL);   
       default:
@@ -1909,6 +1912,7 @@
         return ASMOP_BC;
       else
         return ASMOP_DE;
+    case 3:
     case 4:
       return (IS_SM83 ? ASMOP_DEBC : ASMOP_HLDE);   
     default:
@@ -1931,7 +1935,7 @@
 
   if (FUNC_ISZ88DK_FASTCALL (ftype))
     {
-      if (i != 1)
+      if (i != 1 || IS_STRUCT (args->type))
         return false;
 
       switch (getSize (args->type))
@@ -1947,7 +1951,7 @@
         }
     }
     
-  // Old SDCC calling convention.
+  // Old SDCC calling convention: Pass everything on the stack.
   if (FUNC_SDCCCALL (ftype) == 0 || FUNC_ISSMALLC (ftype) || IFFUNC_ISBANKEDCALL (ftype))
     return 0;
 
@@ -1961,6 +1965,9 @@
       for (j = 1, arg = args; j < i; j++, arg = arg->next)
         wassert (arg);
 
+      if (IS_STRUCT (arg->type))
+        return 0;
+
       if (i == 1 && getSize (arg->type) == 1)
         return ASMOP_A;
       if (i == 1 && getSize (arg->type) == 2)
@@ -3437,6 +3444,14 @@
 #endif
     }
 
+  if((IS_EZ80_Z80 || IS_Z80N) && to_index && (from->type == AOP_LIT || from->type == AOP_IMMD))
+    {
+      if (!regalloc_dry_run)
+        aopPut (to, aopGet (from, from_offset, false), to_offset);
+      regalloc_dry_run_cost += ld_cost (to, 0, from_offset < from->size ? from : ASMOP_ZERO, from_offset);
+      return;
+    }
+
   if (to->type == AOP_REG && from_index && !to_index && - _G.stack.pushed - _G.stack.offset >= -128 && !_G.omitFramePtr)
     {
       _push(PAIR_IY);
@@ -4869,9 +4884,10 @@
   while (size--)
     if (size != skipbyte)
       {
-        if (aopInReg (oper->aop, size, IYL_IDX) || aopInReg (oper->aop, size, IYH_IDX))
+        if (!IS_EZ80_Z80 && !IS_Z80N && (aopInReg (oper->aop, size, IYL_IDX) || aopInReg (oper->aop, size, IYH_IDX)))
           UNIMPLEMENTED;
-        emit3_o (A_OR, ASMOP_A, 0, oper->aop, size);
+        else
+          emit3_o (A_OR, ASMOP_A, 0, oper->aop, size);
       }
 }
 
@@ -4887,7 +4903,10 @@
   if (right->aop->size == 1 && !aopInReg (right->aop, 0, A_IDX))
     {
       emit3 (A_XOR, ASMOP_A, ASMOP_A);
-      emit3 (A_CP, ASMOP_A, right->aop);
+      if (!IS_EZ80_Z80 && !IS_Z80N && (aopInReg (right->aop, 0, IYL_IDX) || aopInReg (right->aop, 0, IYH_IDX)))
+        UNIMPLEMENTED;
+      else
+        emit3 (A_CP, ASMOP_A, right->aop);
     }
   else
     {
@@ -5729,7 +5748,7 @@
     if (!isRegDead (argreg->aopu.aop_reg[i]->rIdx, ic))
       for (iCode *walk2 = ic->next; walk2; walk2 = walk2->next)
           {
-            if (walk2->op != CALL && IC_LEFT (walk2) && !IS_OP_LITERAL (IC_LEFT (walk2)))
+            if (walk2->op != CALL && IC_LEFT (walk2) && IS_ITEMP (IC_LEFT (walk2)))
               UNIMPLEMENTED;
 
             if (walk2->op == CALL || walk2->op == PCALL)
@@ -5828,7 +5847,7 @@
               emit2 ("ld b, h");
               regalloc_dry_run_cost += 2;
               _pop (PAIR_HL);
-              pair = PAIR_BC;             
+              pair = PAIR_BC;
             }
         }
       emit2 ("push %s", _pairs[pair].name);
@@ -5841,11 +5860,6 @@
 
   // Check if we can do tail call optimization.
   else if (!(currFunc && IFFUNC_ISISR (currFunc->type)) &&
-    (!SomethingReturned || aopInReg (IC_RESULT (ic)->aop, 0, aopRet (ftype)->aopu.aop_reg[0]->rIdx) &&
-      (IC_RESULT (ic)->aop->size <= 1 || aopInReg (IC_RESULT (ic)->aop, 1, aopRet (ftype)->aopu.aop_reg[1]->rIdx)) &&
-      (IC_RESULT (ic)->aop->size <= 2 || aopInReg (IC_RESULT (ic)->aop, 2, aopRet (ftype)->aopu.aop_reg[2]->rIdx)) &&
-      (IC_RESULT (ic)->aop->size <= 3 || aopInReg (IC_RESULT (ic)->aop, 3, aopRet (ftype)->aopu.aop_reg[3]->rIdx)) &&
-      IC_RESULT (ic)->aop->size <= 4) &&
     !ic->parmBytes &&
     (!isFuncCalleeStackCleanup (currFunc->type) || !ic->parmEscapeAlive && ic->op == CALL && 0 /* todo: test and enable depending on optimization goal - as done for stm8 - for z80 and r3ka this will be slower and bigger than without tail call optimization, but it saves RAM */) &&
     !ic->localEscapeAlive &&
@@ -5918,6 +5932,11 @@
         }
     }
 
+  if (tailjump && SomethingReturned) // Explicitly check for matching registers, as otherwise calls between __sdcccall(1) and __z88dk_fastcall will go wrong.
+    for (int i = 0; i < IC_RESULT (ic)->aop->size; i++)
+      if (!aopInReg (aopRet (currFunc->type), 0, aopRet (ftype)->aopu.aop_reg[0]->rIdx))
+        tailjump = false;
+
   const bool jump = tailjump || !ic->parmBytes && !bigreturn && ic->op != PCALL && !IFFUNC_ISBANKEDCALL (dtype) && !IFFUNC_ISZ88DK_SHORTCALL(ftype) && IFFUNC_ISNORETURN (ftype);
 
   if (ic->op == PCALL)
@@ -6982,7 +7001,10 @@
               offset += 2;
               break;
             }
-          emit3_o (A_INC, IC_RESULT (ic)->aop, offset++, 0, 0);
+          if (!IS_EZ80_Z80 && !IS_Z80N && (aopInReg (IC_RESULT (ic)->aop, offset, IYL_IDX) || aopInReg (IC_RESULT (ic)->aop, offset, IYH_IDX)))
+            UNIMPLEMENTED;
+          else
+            emit3_o (A_INC, IC_RESULT (ic)->aop, offset++, 0, 0);
           if (size)
             {
               if (!regalloc_dry_run)
@@ -7008,7 +7030,10 @@
     {
       cheapMove (IC_RESULT (ic)->aop, LSB, IC_LEFT (ic)->aop, LSB, true);
       while (icount--)
-        emit3_o (A_INC, IC_RESULT (ic)->aop, LSB, 0, 0);
+        if (!IS_EZ80_Z80 && !IS_Z80N && (aopInReg (IC_RESULT (ic)->aop, 0, IYL_IDX) || aopInReg (IC_RESULT (ic)->aop, 0, IYH_IDX)))
+          UNIMPLEMENTED;
+        else
+          emit3_o (A_INC, IC_RESULT (ic)->aop, 0, 0, 0);
       return TRUE;
     }
 
@@ -7841,6 +7866,8 @@
             }
           else if (rightop->type == AOP_STL && i < 2)
             UNIMPLEMENTED;
+          else if (!IS_EZ80_Z80 && !IS_Z80N && (aopInReg (rightop, i, IYL_IDX) || aopInReg (rightop, i, IYH_IDX)))
+            UNIMPLEMENTED;
           else
             {
               emit3_o (started ? A_ADC : A_ADD, ASMOP_A, 0, rightop, i);
@@ -7900,7 +7927,7 @@
 genMinusDec (const iCode *ic, asmop *result, asmop *left, asmop *right)
 {
   unsigned int icount;
-  unsigned int size = getDataSize (IC_RESULT (ic));
+  unsigned int size;
 
   /* will try to generate a decrement */
   /* if the right side is not a literal we cannot */
@@ -8137,7 +8164,10 @@
               pushed_hl = true;
             }
 
-          if (!offset)
+
+          if ((aopInReg (right, offset, IYL_IDX)  || aopInReg (right, offset, IYH_IDX)) && !IS_EZ80_Z80 && !IS_Z80N) // From here on all codepaths needs to use right as operand.
+            UNIMPLEMENTED;
+          else if (!offset)
             {
               if (left->type == AOP_LIT && byteOfVal (left->aopu.aop_lit, offset) == 0x00 && aopInReg (right, offset, A_IDX))
                 emit3 (A_NEG, 0, 0);
@@ -10163,7 +10193,8 @@
             }
           /* Non-destructive and when exactly one bit per byte is set. */
           else if (isLiteralBit (bytelit) >= 0 &&
-            (left->aop->type == AOP_STK || aopInReg (left->aop, 0, A_IDX) || left->aop->type == AOP_HL || left->aop->type == AOP_IY || left->aop->type == AOP_REG && left->aop->aopu.aop_reg[0]->rIdx != IYL_IDX))
+            (left->aop->type == AOP_STK || aopInReg (left->aop, offset, A_IDX) || left->aop->type == AOP_HL || left->aop->type == AOP_IY ||
+              left->aop->type == AOP_REG && !aopInReg (left->aop, offset, IYL_IDX) && !aopInReg (left->aop, offset, IYH_IDX)))
             {
               if (requiresHL (left->aop) && left->aop->type != AOP_REG)
                 _push (PAIR_HL);
@@ -10279,8 +10310,8 @@
               i = end;
               continue;
             }
-          else if (isLiteralBit (~bytelit & 0xffu) >= 0 &&
-            (result->aop->type == AOP_REG || left == right && (result->aop->type == AOP_STK || result->aop->type == AOP_DIR)))
+          else if (isLiteralBit (~bytelit & 0xffu) >= 0 && aopSame (result->aop, i, left->aop, i, 1) &&
+            (result->aop->type == AOP_STK || result->aop->type == AOP_DIR || result->aop->type == AOP_REG && !aopInReg (result->aop, i, IYL_IDX) && !aopInReg (result->aop, i, IYH_IDX)))
             {
               cheapMove (result->aop, i, left->aop, i, a_free);
               if (!regalloc_dry_run)
@@ -10357,7 +10388,10 @@
         {
           if (requiresHL (left->aop) && left->aop->type != AOP_REG && !hl_free)
             _push (PAIR_HL);
-          emit3_o (A_AND, ASMOP_A, 0, left->aop, i);
+          if (!IS_EZ80_Z80 && !IS_Z80N && (aopInReg (left->aop, i, IYL_IDX) || aopInReg (left->aop, i, IYH_IDX)))
+            UNIMPLEMENTED;
+          else
+            emit3_o (A_AND, ASMOP_A, 0, left->aop, i);
           if (requiresHL (left->aop) && left->aop->type != AOP_REG && !hl_free)
             _pop (PAIR_HL);
         }
@@ -10371,7 +10405,10 @@
 
           if (requiresHL (right->aop) && right->aop->type != AOP_REG && !hl_free)
             _push (PAIR_HL);
-          emit3_o (A_AND, ASMOP_A, 0, right->aop, i);
+          if (!IS_EZ80_Z80 && !IS_Z80N && (aopInReg (right->aop, i, IYL_IDX) || aopInReg (right->aop, i, IYH_IDX)))
+            UNIMPLEMENTED;
+          else
+            emit3_o (A_AND, ASMOP_A, 0, right->aop, i);
           if (requiresHL (right->aop) && right->aop->type != AOP_REG && !hl_free)
             _pop (PAIR_HL);
         }
@@ -10551,8 +10588,8 @@
               i = end;
               continue;
             }
-          else if (isLiteralBit (bytelit) >= 0 &&
-            (result->aop->type == AOP_REG || left == right && (result->aop->type == AOP_STK || result->aop->type == AOP_DIR)))
+          else if (isLiteralBit (bytelit) >= 0 && aopSame (result->aop, i, left->aop, i, 1) &&
+            (result->aop->type == AOP_STK || result->aop->type == AOP_DIR || result->aop->type == AOP_REG && !aopInReg (result->aop, i, IYL_IDX) && !aopInReg (result->aop, i, IYH_IDX)))
             {
               cheapMove (result->aop, i, left->aop, i, a_free);
               if (!regalloc_dry_run)
@@ -10913,7 +10950,10 @@
           {
             if (requiresHL (left_aop) && left_aop->type != AOP_REG && !hl_free)
               _push (PAIR_HL);
-            emit3_o (A_XOR, ASMOP_A, 0, left_aop, i);
+            if (!IS_EZ80_Z80 && !IS_Z80N && (aopInReg (left_aop, i, IYL_IDX) || aopInReg (left_aop, i, IYH_IDX)))
+              UNIMPLEMENTED;
+            else
+              emit3_o (A_XOR, ASMOP_A, 0, left_aop, i);
             if (requiresHL (left_aop) && left_aop->type != AOP_REG && !hl_free)
               _pop (PAIR_HL);
           }
@@ -10928,6 +10968,8 @@
                _pop (PAIR_HL);
             if (right_aop->type == AOP_LIT && byteOfVal (right_aop->aopu.aop_lit, i) == 0xff)
               emit3 (A_CPL, 0, 0);
+            else if (!IS_EZ80_Z80 && !IS_Z80N && (aopInReg (right_aop, i, IYL_IDX) || aopInReg (right_aop, i, IYH_IDX)))
+              UNIMPLEMENTED;
             else
               {
                 if (requiresHL (right_aop) && right_aop->type != AOP_REG && !hl_free)
@@ -12870,7 +12912,7 @@
   operand *left, *right, *result;
   int size, offset, rightval;
   int pair = PAIR_HL, extrapair;
-  sym_link *retype;
+  bool bit_field;
   bool pushed_pair = FALSE;
   bool pushed_a = FALSE;
   bool surviving_a = !isRegDead (A_IDX, ic);
@@ -12879,7 +12921,7 @@
   left = IC_LEFT (ic);
   right = IC_RIGHT (ic);
   result = IC_RESULT (ic);
-  retype = getSpec (operandType (result));
+  bit_field = IS_BITVAR (operandType (result)); // Should be IS_BITVAR (operandType (left)->next), but conflicts with optimizations that reuses pointers (when reading from a union of a struct containing bit-fields and other types).
 
   aopOp (left, ic, FALSE, FALSE);
   aopOp (result, ic, FALSE, FALSE);
@@ -12896,7 +12938,7 @@
   if ((IS_SM83 || IY_RESERVED) && requiresHL (result->aop) && size > 1 && result->aop->type != AOP_REG)
     pair = PAIR_DE;
 
-  if (IS_SM83 && size == 1 && left->aop->type == AOP_LIT && (((unsigned long)(operandLitValue (left) + rightval) & 0xff00) == 0xff00) && isRegDead (A_IDX, ic) && !IS_BITVAR (retype)) // SM83 has special instructions for address range 0xff00 - 0xffff.
+  if (IS_SM83 && size == 1 && left->aop->type == AOP_LIT && (((unsigned long)(operandLitValue (left) + rightval) & 0xff00) == 0xff00) && isRegDead (A_IDX, ic) && !bit_field) // SM83 has special instructions for address range 0xff00 - 0xffff.
     {
       emit2 ("ldh a, !mems", aopGetLitWordLong (left->aop, rightval, true));
       cost (2, 12);
@@ -12903,13 +12945,13 @@
       cheapMove (result->aop, 0, ASMOP_A, 0, true);
       goto release;
     }
-  if ((left->aop->type == AOP_IMMD || left->aop->type == AOP_LIT && !rightval) && size == 1 && aopInReg (result->aop, 0, A_IDX) && !IS_BITVAR (retype))
+  if ((left->aop->type == AOP_IMMD || left->aop->type == AOP_LIT && !rightval) && size == 1 && aopInReg (result->aop, 0, A_IDX) && !bit_field)
     {
       emit2 ("ld a, !mems", aopGetLitWordLong (left->aop, rightval, true));
       regalloc_dry_run_cost += 3;
       goto release;
     }
-  else if (!IS_SM83 && (left->aop->type == AOP_IMMD || left->aop->type == AOP_LIT && !rightval) && isPair (result->aop) && !IS_BITVAR (retype))
+  else if (!IS_SM83 && (left->aop->type == AOP_IMMD || left->aop->type == AOP_LIT && !rightval) && isPair (result->aop) && !bit_field)
     {
       PAIR_ID pair = getPairId (result->aop);
       emit2 ("ld %s, !mems", _pairs[pair].name, aopGetLitWordLong (left->aop, rightval, TRUE));
@@ -12927,7 +12969,7 @@
       regalloc_dry_run_cost += (pair == PAIR_HL ? 3 : 4);
       goto release;
     }
-  else if (left->aop->type == AOP_STL && !IS_BITVAR (retype) && size <= 4)
+  else if (left->aop->type == AOP_STL && !bit_field && size <= 4)
     {
       struct asmop saop;
       init_stackop (&saop, size, left->aop->aopu.aop_stk + rightval);
@@ -12938,7 +12980,7 @@
   if (IS_SM83)
     wassert (!rightval);
 
-  if (isPair (left->aop) && size == 1 && !IS_BITVAR (retype) && !rightval)
+  if (isPair (left->aop) && size == 1 && !bit_field && !rightval)
     {
       /* Just do it */
       if ((getPairId (left->aop) == PAIR_HL || getPairId (left->aop) == PAIR_IY) && result->aop->type == AOP_REG)
@@ -12966,7 +13008,7 @@
       goto release;
     }
 
-  if (getPairId (left->aop) == PAIR_IY && !IS_BITVAR (retype) && rightval_in_range)
+  if (getPairId (left->aop) == PAIR_IY && !bit_field && rightval_in_range)
     {
       offset = 0;
 
@@ -13011,7 +13053,7 @@
     }
 
   /* Using ldir is cheapest for large memory-to-memory transfers. */
-  if (!IS_SM83 && !IS_R2K && !IS_R2KA && (result->aop->type == AOP_STK || result->aop->type == AOP_EXSTK) && size > 2)
+  if (!IS_SM83 && !IS_R2K && !IS_R2KA && !bit_field && (result->aop->type == AOP_STK || result->aop->type == AOP_EXSTK) && size > 2)
     {
       int fp_offset, sp_offset;
 
@@ -13092,7 +13134,7 @@
 
   extrapair = isPairDead (PAIR_DE, ic) ? PAIR_DE : PAIR_BC;
 
-  if (!surviving_a && (getPairId (left->aop) == PAIR_BC || getPairId (left->aop) == PAIR_DE) && isPairDead (getPairId (left->aop), ic) && abs(rightval) <= 2 && !IS_BITVAR (retype) && size < 2) // Use inc ss (size < 2 condition to avoid overwriting pair with result)
+  if (!surviving_a && (getPairId (left->aop) == PAIR_BC || getPairId (left->aop) == PAIR_DE) && isPairDead (getPairId (left->aop), ic) && abs(rightval) <= 2 && !bit_field && size < 2) // Use inc ss (size < 2 condition to avoid overwriting pair with result)
     pair = getPairId (left->aop);
 
   /* For now we always load into temp pair */
@@ -13102,7 +13144,7 @@
     pair = getPairId (left->aop);
   else
     {
-      if (!isPairDead (pair, ic) && size > 1 && (getPairId (left->aop) != pair || rightval || IS_BITVAR (retype) || size > 2)) // For simple cases, restoring via dec is cheaper than push / pop.
+      if (!isPairDead (pair, ic) && size > 1 && (getPairId (left->aop) != pair || rightval || bit_field || size > 2)) // For simple cases, restoring via dec is cheaper than push / pop.
         _push (pair), pushed_pair = TRUE;
       if (left->aop->type == AOP_IMMD)
         {
@@ -13132,7 +13174,7 @@
     }
 
   /* if bit then unpack */
-  if (IS_BITVAR (retype))
+  if (bit_field)
     {
       offsetPair (pair, extrapair, !isPairDead (extrapair, ic), rightval);
       genUnpackBits (result, pair, ic);
@@ -13142,7 +13184,7 @@
       goto release;
     }
 
- if (isPair (result->aop) && IS_EZ80_Z80 && getPairId (left->aop) == PAIR_HL && !IS_BITVAR (retype) && !rightval)
+ if (isPair (result->aop) && IS_EZ80_Z80 && getPairId (left->aop) == PAIR_HL && !bit_field && !rightval)
    {
      emit2 ("ld %s, !*hl", _pairs[getPairId (result->aop)].name);
      regalloc_dry_run_cost += 2;
@@ -13639,9 +13681,7 @@
   int last_offset = 0;
   operand *right, *result;
   PAIR_ID pairId = PAIR_HL;
-  bool isBitvar;
-  sym_link *retype;
-  sym_link *letype;
+  bool bit_field;
   bool pushed_a = false;
   bool pushed_pair = false;
   bool surviving_a = !isRegDead (A_IDX, ic);
@@ -13648,9 +13688,10 @@
 
   right = IC_RIGHT (ic);
   result = IC_RESULT (ic);
-  retype = getSpec (operandType (right));
-  letype = getSpec (operandType (result));
 
+  wassert (operandType (result)->next);
+  bit_field = IS_BITVAR (operandType (result)->next);
+
   aopOp (result, ic, FALSE, FALSE);
   aopOp (right, ic, FALSE, FALSE);
 
@@ -13663,10 +13704,7 @@
 
   size = right->aop->size;
 
-  isBitvar = IS_BITVAR (retype) || IS_BITVAR (letype);
-  emitDebug ("; isBitvar = %d", isBitvar);
-
-  if (IS_SM83 && size == 1 && result->aop->type == AOP_LIT && (((unsigned long)operandLitValue (result) & 0xff00) == 0xff00) && (isRegDead (A_IDX, ic) || aopInReg (right->aop, 0, A_IDX)) && !isBitvar) // SM83 has special instructions for address range 0xff00 - 0xffff.
+  if (IS_SM83 && size == 1 && result->aop->type == AOP_LIT && (((unsigned long)operandLitValue (result) & 0xff00) == 0xff00) && (isRegDead (A_IDX, ic) || aopInReg (right->aop, 0, A_IDX)) && !bit_field) // SM83 has special instructions for address range 0xff00 - 0xffff.
     {
       cheapMove (ASMOP_A, 0, right->aop, 0, isRegDead (A_IDX, ic));
       emit2 ("ldh !mems, a", aopGetLitWordLong (result->aop, 0, true));
@@ -13675,7 +13713,7 @@
     }
 
   /* Handle the exceptions first */
-  if (isPair (result->aop) && size == 1 && !isBitvar)
+  if (isPair (result->aop) && size == 1 && !bit_field)
     {
       /* Just do it */
       const char *pair = getPairName (result->aop);
@@ -13700,7 +13738,7 @@
     }
 
   /* Rematerialized stack location */
-  if (result->aop->type == AOP_STL && !isBitvar && size <= 4)
+  if (result->aop->type == AOP_STL && !bit_field && size <= 4)
     {
       struct asmop saop;
       init_stackop (&saop, size, result->aop->aopu.aop_stk);
@@ -13709,7 +13747,7 @@
     }
 
   /* Using ldir is cheapest for large memory-to-memory transfers. */
-  if (!IS_SM83 && !IS_R2K && !IS_R2KA && (right->aop->type == AOP_STK || right->aop->type == AOP_EXSTK) && size > 2)
+  if (!IS_SM83 && !IS_R2K && !IS_R2KA && !bit_field && (result->aop->type == AOP_STK || result->aop->type == AOP_EXSTK) && size > 2)
     {
       int fp_offset, sp_offset;
 
@@ -13739,7 +13777,7 @@
       goto release;
     }
 
-  if (getPairId (result->aop) == PAIR_IY && !isBitvar)
+  if (getPairId (result->aop) == PAIR_IY && !bit_field)
     {
       /* Just do it */
       while (size--)
@@ -13760,7 +13798,7 @@
         }
       goto release;
     }
-  else if (getPairId (result->aop) == PAIR_HL && !isPairDead (PAIR_HL, ic) && !isBitvar)
+  else if (getPairId (result->aop) == PAIR_HL && !isPairDead (PAIR_HL, ic) && !bit_field)
     {
       while (offset < size)
         {
@@ -13816,7 +13854,7 @@
       goto release;
     }
 
-  if (!IS_SM83 && !isBitvar && isLitWord (result->aop) && size == 2 && offset == 0 &&
+  if (!IS_SM83 && !bit_field && isLitWord (result->aop) && size == 2 && offset == 0 &&
       (right->aop->type == AOP_REG && getPairId (right->aop) != PAIR_INVALID || isLitWord (right->aop)))
     {
       if (isLitWord (right->aop))
@@ -13830,7 +13868,7 @@
       regalloc_dry_run_cost += (pairId == PAIR_HL) ? 3 : 4;
       goto release;
     }
-  if (!IS_SM83 && !isBitvar && isLitWord (result->aop) && size == 4 && offset == 0 &&
+  if (!IS_SM83 && !bit_field && isLitWord (result->aop) && size == 4 && offset == 0 &&
     (getPartPairId (right->aop, 0) != PAIR_INVALID && getPartPairId (right->aop, 2) != PAIR_INVALID || isLitWord (right->aop)))
     {
       if (isLitWord (right->aop))
@@ -13858,7 +13896,7 @@
      then we do nothing else we move the value to dptr */
   if (result->aop->type != AOP_STR)
     {
-      if (isBitvar && getPairId (result->aop) != PAIR_INVALID && (getPairId (result->aop) != PAIR_IY || SPEC_BLEN (IS_BITVAR (retype) ? retype : letype) < 8 || isPairDead (getPairId (result->aop), ic)))   /* Avoid destroying result by increments */
+      if (bit_field && getPairId (result->aop) != PAIR_INVALID && (getPairId (result->aop) != PAIR_IY || SPEC_BLEN (getSpec (operandType (result)->next)) < 8 || isPairDead (getPairId (result->aop), ic)))   /* Avoid destroying result by increments */
         pairId = getPairId (result->aop);
       else
         {
@@ -13874,9 +13912,9 @@
   /*freeAsmop (result, NULL, ic);*/
 
   /* if bit then unpack */
-  if (isBitvar)
+  if (bit_field)
     {
-      genPackBits ((IS_BITVAR (retype) ? retype : letype), right, pairId, ic);
+      genPackBits (getSpec (operandType (result)->next), right, pairId, ic);
       goto release;
     }
   else
@@ -13971,7 +14009,7 @@
   aopOp (cond, ic, FALSE, TRUE);
 
   /* Special case: Condition is bool */
-  if (IS_BOOL (operandType (cond)) && !aopInReg (cond->aop, 0, A_IDX))
+  if (IS_BOOL (operandType (cond)) && !aopInReg (cond->aop, 0, A_IDX) && !aopInReg (cond->aop, 0, IYL_IDX) && !aopInReg (cond->aop, 0, IYH_IDX))
     {
       if (!regalloc_dry_run)
         {
@@ -15513,7 +15551,6 @@
   freeAsmop (c, NULL);
   freeAsmop (dst, NULL);
 
-
   if (saved_BC)
     _pop (PAIR_BC);
   if (saved_DE)
@@ -16102,7 +16139,7 @@
       break;
 
     default:
-      ;
+      wassertl (0, "Unknown iCode");
     }
 }
 
@@ -16281,3 +16318,4 @@
   return false;
 }
 
+
Index: src/z80/main.c
===================================================================
--- src/z80/main.c	(revision 13131)
+++ src/z80/main.c	(working copy)
@@ -1114,7 +1114,7 @@
     1                           /* No fancy alignments supported. */
   },
   { NULL, NULL },
-  1,                            /* ABI revision */
+  0,                            /* ABI revision */
   { -1, 0, 0, 4, 0, 3, 0 },
   { 
     -1,                         /* shifts never use support routines */
@@ -1246,7 +1246,7 @@
     1                           /* No fancy alignments supported. */
   },
   { NULL, NULL },
-  1,                            /* ABI revision */
+  0,                            /* ABI revision */
   { -1, 0, 0, 4, 0, 3, 0 },
   { -1, FALSE },
   { z80_emitDebuggerSymbol },
@@ -1763,7 +1763,7 @@
     1                           /* No fancy alignments supported. */
   },
   { NULL, NULL },
-  1,                            /* default ABI revision */
+  0,                            /* ABI revision */
   { -1, 0, 0, 2, 0, 4, 0 },
   { -1, FALSE },
   { z80_emitDebuggerSymbol },
@@ -2150,7 +2150,7 @@
     1                           /* No fancy alignments supported. */
   },
   { NULL, NULL },
-  1,                            /* ABI revision */
+  0,                            /* ABI revision */
   { -1, 0, 0, 4, 0, 3, 0 },
   { -1, FALSE },
   { z80_emitDebuggerSymbol },
Index: src/z80/peep.c
===================================================================
--- src/z80/peep.c	(revision 13131)
+++ src/z80/peep.c	(working copy)
@@ -165,6 +165,88 @@
   return(found && found < end);
 }
 
+/* z88dk special functions with register parameters listed */
+static char *special_funcs[][3] = {
+/* [0] = call function name, [1] = input registers, [2] = preserved registers */
+  {"call\t____sdcc_ll_copy_src_hlsp_dst_de", "dehl", "ay"},
+  {"call\t____sdcc_ll_copy_src_de_dst_hlsp", "dehl", "ay"},
+  {"call\t____sdcc_ll_add_deix_hlix", "dehl", "bcy"},
+  {"call\t____sdcc_ll_sub_deix_hlix", "dehl", "bcy"},
+  {"call\t____sdcc_ll_push_hlix", "hl", "bcy"},
+  {"call\t____sdcc_ll_copy_src_hlsp_dst_deixm", "dehl", "ay"},
+  {"call\t____sdcc_ll_copy_src_deixm_dst_hlsp", "dehl", "ay"},
+  {"call\t____sdcc_ll_asr_hlix_a", "ahl", "y"},
+  {"call\t____sdcc_ll_lsr_hlix_a", "ahl", "y"},
+  {"call\t____sdcc_ll_lsl_hlix_a", "ahl", "y"},
+  {"call\t____sdcc_ll_push_mhl", "hl", "bcy"},
+  {"call\t____sdcc_ll_copy_src_deix_dst_hl", "dehl", "ay"},
+  {"call\t____sdcc_ll_add_deix_bc_hl", "bcdehl", "y"},
+  {"call\t____sdcc_ll_sub_deix_bc_hl", "bcdehl", "y"},
+  {"call\t____sdcc_ll_copy_src_desp_dst_hlsp", "dehl", "ay"},
+  {"call\t____sdcc_ll_copy_src_de_dst_hlix", "dehl", "ay"},
+  {"call\t____sdcc_ll_add_de_bc_hl", "bcdehl", "y"},
+  {"call\t____sdcc_ll_sub_de_bc_hl", "bcdehl", "y"},
+  {"call\t____sdcc_ll_copy_src_hl_dst_de", "dehl", "ay"},
+  {"call\t____sdcc_ll_asr_mbc_a", "abc", "y"},
+  {"call\t____sdcc_ll_lsl_mbc_a", "abc", "y"},
+  {"call\t____sdcc_ll_lsr_mbc_a", "abc", "y"},
+  {"call\t____sdcc_ll_add_hlix_deix_bcix", "bcdehl", "y"},
+  {"call\t____sdcc_ll_sub_hlix_deix_bcix", "bcdehl", "y"},
+  {"call\t____sdcc_ll_copy_src_deix_dst_hlix", "dehl", "ay"},
+  {"call\t____sdcc_ll_add_hlix_bc_deix", "bcdehl", "y"},
+  {"call\t____sdcc_ll_sub_hlix_bc_deix", "bcdehl", "y"},
+  {"call\t____sdcc_ll_add_hlix_deix_bc", "bcdehl", "y"},
+  {"call\t____sdcc_ll_sub_hlix_deix_bc", "bcdehl", "y"},
+  {"call\t____sdcc_ll_add_de_hlix_bcix", "bcdehl", "y"},
+  {"call\t____sdcc_ll_sub_de_hlix_bcix", "bcdehl", "y"},
+  {"call\t____sdcc_ll_add_de_bc_hlix", "bcdehl", "y"},
+  {"call\t____sdcc_ll_sub_de_bc_hlix", "bcdehl", "y"},
+  {"call\t____sdcc_ll_add_de_hlix_bc", "bcdehl", "y"},
+  {"call\t____sdcc_ll_sub_de_hlix_bc", "bcdehl", "y"},
+  {"call\t____sdcc_cpu_push_di", "", "bcdehly"},
+  {"call\t____sdcc_cpu_pop_ei", "", "bcdehly"},
+  {"call\t____sdcc_lib_setmem_hl", "ahl", "abcdey"},
+  {"call\t____sdcc_load_debc_deix", "de", "ahly"},
+  {"call\t____sdcc_load_dehl_deix", "de", "bcy"},
+  {"call\t____sdcc_load_debc_mhl", "hl", "ay"},
+  {"call\t____sdcc_load_hlde_mhl", "hl", "bcy"},
+  {"call\t____sdcc_4_copy_src_mhl_dst_deix", "dehl", "bcy"},
+  {"call\t____sdcc_4_copy_src_mhl_dst_bcix", "bchl", "bcdey"},
+  {"call\t____sdcc_4_copy_src_mhl_dst_mbc", "bchl", "dey"},
+  {"call\t____sdcc_4_push_hlix", "hl", "bcdey"},
+  {"call\t____sdcc_4_push_mhl", "hl", "bcdey"},
+  {"call\t____sdcc_store_debc_hlix", "bcdehl", "abcdey"},
+  {"call\t____sdcc_store_debc_mhl", "bcdehl", "abcdey"},
+  {"call\t____sdcc_store_dehl_bcix", "bcdehl", "adehly"},
+  {"call\t____sdcc_2_copy_src_mhl_dst_deix", "dehl", "bcy"},
+  {"call\t____sdcc_2_copy_src_mhl_dst_bcix", "bchl", "debcy"},
+  {"call\t____sdcc_4_ldi_nosave_bc", "dehl", "y"},
+  {"call\t____sdcc_4_ldi_save_bc", "dehl", "bcy"},
+  {"call\t____sdcc_outi_128", "bchl", "acdey"},
+  {"call\t____sdcc_outi_256", "bchl", "acdey"},
+  {"call\t____sdcc_outi", "bchl", "acdey"},
+  {"call\t____sdcc_ldi_128", "bcdehl", "ay"},
+  {"call\t____sdcc_ldi_256", "bcdehl", "ay"},
+  {"call\t____sdcc_ldi", "bcdehl", "ay"},
+  {"call\t____sdcc_4_copy_srcd_hlix_dst_deix","dehl","y" },
+  {"call\t____sdcc_4_and_src_mbc_mhl_dst_deix","bcdehl","y" },
+  {"call\t____sdcc_4_or_src_mbc_mhl_dst_deix","bcdehl","y" },
+  {"call\t____sdcc_4_xor_src_mbc_mhl_dst_deix","bcdehl","y" },
+  {"call\t____sdcc_4_or_src_dehl_dst_bcix","bcdehl","dehly" },
+  {"call\t____sdcc_4_xor_src_dehl_dst_bcix","bcdehl","dehly" },
+  {"call\t____sdcc_4_and_src_dehl_dst_bcix","bcdehl","dehly" },
+  {"call\t____sdcc_4_xor_src_mbc_mhl_dst_debc","bcdehl","y" },
+  {"call\t____sdcc_4_or_src_mbc_mhl_dst_debc","bcdehl","y" },
+  {"call\t____sdcc_4_and_src_mbc_mhl_dst_debc","bcdehl","y" },
+  {"call\t____sdcc_4_cpl_src_mhl_dst_debc","hl","y" },
+  {"call\t____sdcc_4_xor_src_debc_mhl_dst_debc","bcdehl","y" },
+  {"call\t____sdcc_4_or_src_debc_mhl_dst_debc","bcdehl","y" },
+  {"call\t____sdcc_4_and_src_debc_mhl_dst_debc","bcdehl","y" },
+  {"call\t____sdcc_4_and_src_debc_hlix_dst_debc","bcdehl","y" },
+  {"call\t____sdcc_4_or_src_debc_hlix_dst_debc","bcdehl","y" },
+  {"call\t____sdcc_4_xor_src_debc_hlix_dst_debc","bcdehl","y" }
+};
+
 static bool
 z80MightBeParmInCallFromCurrentFunction(const char *what)
 {
@@ -332,6 +414,8 @@
 static bool
 z80MightRead(const lineNode *pl, const char *what)
 {
+  int i;
+
   if(strcmp(what, "iyl") == 0 || strcmp(what, "iyh") == 0)
     what = "iy";
   if(strcmp(what, "ixl") == 0 || strcmp(what, "ixh") == 0)
@@ -340,6 +424,16 @@
   if(ISINST(pl->line, "call") && strcmp(what, "sp") == 0)
     return TRUE;
 
+  /* look for z88dk special functions */
+  if (strstr(pl->line, "call\t____sdcc") != 0)
+  {
+    for (i = 0; i < sizeof(special_funcs) / (3 * sizeof(char *)); ++i)
+      {
+        if (strstr(pl->line, special_funcs[i][0]) != 0)
+          return (strchr(special_funcs[i][1], (what[1] == '\0') ? what[0] : what[1]) != 0);
+      }
+  }
+
   if(strcmp(pl->line, "call\t__initrleblock") == 0 && (strchr(what, 'd') != 0 || strchr(what, 'e') != 0))
     return TRUE;
 
@@ -785,6 +879,7 @@
     return(true);
   if(ISINST(pl->line, "call") && strchr(pl->line, ',') == 0)
     {
+      int i;
       const symbol *f = findSym (SymbolTab, 0, pl->line + 6);
       const bool *preserved_regs;
 
@@ -791,6 +886,16 @@
       if(!strcmp(what, "ix"))
         return(false);
 
+      /* z88dk special functions */
+      if(!f && (strstr(pl->line, "call\t____sdcc") != 0))
+        {
+           for (i = 0; i < sizeof(special_funcs) / (3*sizeof(char *)); ++i)
+             {
+                if (strstr(pl->line, special_funcs[i][0]) != 0)
+                  return (strchr(special_funcs[i][2], (what[1] == '\0') ? what[0] : what[1]) == 0);
+             }
+        }
+
       if(f)
           preserved_regs = f->type->funcAttrs.preserved_regs;
       else // Err on the safe side.
Index: src/z80/ralloc2.cc
===================================================================
--- src/z80/ralloc2.cc	(revision 13131)
+++ src/z80/ralloc2.cc	(working copy)
@@ -1001,6 +1001,13 @@
   bool result_in_IYH = operand_in_reg(result, REG_IYH, ia, i, G);
   bool result_in_IY = result_in_IYL || result_in_IYH;
 
+  const cfg_dying_t &dying = G[i].dying;
+
+  bool dead_IYL = result_in_IYL || unused_IYL || dying.find(ia.registers[REG_IYL][1]) != dying.end() || dying.find(ia.registers[REG_IYL][0]) != dying.end();
+  bool dead_IYH = result_in_IYH || unused_IYH || dying.find(ia.registers[REG_IYH][1]) != dying.end() || dying.find(ia.registers[REG_IYH][0]) != dying.end();
+
+  bool dead_IY = dead_IYL && dead_IYH;
+
   bool input_in_IYL, input_in_IYH;
   switch(ic->op)
     {
@@ -1019,13 +1026,6 @@
     }
   bool input_in_IY = input_in_IYL || input_in_IYH;
 
-  //const std::set<var_t> &dying = G[i].dying;
-  
-  //bool dying_IYL = result_in_IYL || dying.find(ia.registers[REG_IYL][1]) != dying.end() || dying.find(ia.registers[REG_IYL][0]) != dying.end();
-  //bool dying_IYH = result_in_IYH || dying.find(ia.registers[REG_IYH][1]) != dying.end() || dying.find(ia.registers[REG_IYH][0]) != dying.end();
-
-  //bool result_only_IY = (result_in_IYL || unused_IYL || dying_IYL) && (result_in_IYH || unused_IYH || dying_IYH);
-
   if(unused_IYL && unused_IYH)
     return(true); // Register IY not in use.
 
@@ -1038,7 +1038,6 @@
   // Some instructions can handle anything.
   if(ic->op == IPUSH || ic->op == CALL ||
     ic->op == '+' ||
-    ic->op == '|' ||
     ic->op == GETBYTE || ic->op == GETWORD || ic->op == SWAP && (getSize(operandType(IC_RESULT (ic))) == 1 || operand_in_reg(result, ia, i, G)) ||
     ic->op == '=' && !POINTER_SET(ic) ||
     ic->op == CAST ||
@@ -1045,6 +1044,7 @@
     ic->op == SEND)
     return(true);
 
+  // Avoid overwriting operand in iy by use of iy as pointer reg to global operand.
   if(!result_in_IY && !input_in_IY &&
     !(IC_RESULT(ic) && isOperandInDirSpace(IC_RESULT(ic))) &&
     !(IC_RIGHT(ic) && IS_TRUE_SYMOP(IC_RIGHT(ic))) &&
@@ -1051,6 +1051,16 @@
     !(IC_LEFT(ic) && IS_TRUE_SYMOP(IC_LEFT(ic))))
     return(true);
 
+  // Some instructions can handle anything if no operand is pointed to by iy.
+  if((!(IC_RESULT(ic) && isOperandInDirSpace(IC_RESULT(ic))) || dead_IY && getSize(operandType(IC_RESULT (ic))) == 1) &&
+    !(IC_RIGHT(ic) && IS_TRUE_SYMOP(IC_RIGHT(ic))) &&
+    !(IC_LEFT(ic) && IS_TRUE_SYMOP(IC_LEFT(ic))) &&
+    (ic->op == '|' ||
+    ic->op == '^' ||
+    ic->op == '~' ||
+    ic->op == BITWISEAND))
+    return(true);
+
   // Code generator mostly cannot handle variables that are only partially in IY.
   if(unused_IYL ^ unused_IYH)
     return(false);
@@ -1070,16 +1080,6 @@
   if(ia.registers[REG_IYL][0] >= 0 && I[ia.registers[REG_IYL][0]].byte != 0 || ia.registers[REG_IYH][0] >= 0 && I[ia.registers[REG_IYH][0]].byte != 1)
     return(false);
 
-#if 0
-  if(ic->key == 32)
-    {
-      std::cout << "A IYinst_ok: Assignment: ";
-      //print_assignment(a);
-      std::cout << "\n";
-      std::cout << "2IYinst_ok: at (" << i << ", " << ic->key << ")\nIYL = (" << ia.registers[REG_IYL][0] << ", " << ia.registers[REG_IYL][1] << "), IYH = (" << ia.registers[REG_IYH][0] << ", " << ia.registers[REG_IYH][1] << ")inst " << i << ", " << ic->key << "\n";
-    }
-#endif
-
   if(result_in_IY &&
     (ic->op == '-' || ic->op == UNARYMINUS)) // todo: More instructions that can write iy.
     return(true);
