#!/usr/bin/perl

#     ZZZZZZZZZZZZZZZZZZZZ    8888888888888       00000000000
#   ZZZZZZZZZZZZZZZZZZZZ    88888888888888888    0000000000000
#                ZZZZZ      888           888  0000         0000
#              ZZZZZ        88888888888888888  0000         0000
#            ZZZZZ            8888888888888    0000         0000       AAAAAA         SSSSSSSSSSS   MMMM       MMMM
#          ZZZZZ            88888888888888888  0000         0000      AAAAAAAA      SSSS            MMMMMM   MMMMMM
#        ZZZZZ              8888         8888  0000         0000     AAAA  AAAA     SSSSSSSSSSS     MMMMMMMMMMMMMMM
#      ZZZZZ                8888         8888  0000         0000    AAAAAAAAAAAA      SSSSSSSSSSS   MMMM MMMMM MMMM
#    ZZZZZZZZZZZZZZZZZZZZZ  88888888888888888    0000000000000     AAAA      AAAA           SSSSS   MMMM       MMMM
#  ZZZZZZZZZZZZZZZZZZZZZ      8888888888888       00000000000     AAAA        AAAA  SSSSSSSSSSS     MMMM       MMMM
#
# Copyright (C) Paulo Custodio, 2011-2013
#
# Parse a list of *.h files and search for init and fini functions. Generates init.c and init.h.
# User code needs to include init.h in any module using the generated functions and in the module
# defining main(), so that main() is renamed to user_main() by init.h.
# The new main() function in init.c calls all init functions found in the parsed *.h files 
# and registers all the fini funtions to run atexit(), and then continues into user_main().
# The initialization sequence is the same as the order the function are retrieved from the
# command line arguments.
#
# Syntax of parsed *.h files:
# extern void init_XXXX(void)		--> generates a call to init_XXXX() from main() before user_main()
#										starts
# extern void fini_XXXX(void)		--> generates a call atexit(fini_XXXX) from main() before user_main()
#										starts
# [typedef] struct YYYY;
# extern void struct_YYYY_init(struct YYYY *x)
#									--> generates a new function struct YYYY *new_YYYY(void)
#									    that allocates zeroed memory for the structure and calls 
#										struct_YYYY_init() to initialize it. The function is 
#										declared in init.h
# extern void struct_YYYY_fini(struct YYYY *x)
#									--> generates a new function void delete_YYYY(struct YYYY **x)
#									    that calls struct_YYYY_fini() to release any resources
#										held by the struture, then frees the allocated memory
#										and zeroes the passed pointer to avoid the freed memory
#										being referenced by mistake. The function is 
#										declared in init.h
# init.o (init.c is generated by this program)
#
# $Header: /home/dom/z88dk-git/cvs/z88dk/src/z80asm/tools/Attic/make_init.pl,v 1.2 2013-09-01 11:59:05 pauloscustodio Exp $
# Log at end of file

use Modern::Perl;
use File::Basename;
use File::Slurp;
use Win32::Autoglob;
use Template::Tiny;

#------------------------------------------------------------------------------
# globals
#------------------------------------------------------------------------------
my $init_re = 			qr/ ^ \s* (?: extern \s+ )?
							  void \s+ 
							  ( ( init | fini ) _ \w+ )
							  \s* \( \s* void \s* \) /ix;	# $1 = func; $2 = init|fini
my $struct_re =			qr/ ^ \s* (?: typedef \s+ )? 
							  struct \s+ (\w+) /ix;			# $1 = struct
my $struct_func_re =	qr/ ^ \s* (?: extern \s+ )?
							  void \s+ 
							  ( struct_ ( \w+ ) _ ( init | fini ) ) \s*
							  \( \s* struct \s+ 
							     \2 \s* \* \s* \w+ \s* \) /ix;	# $1 = func, $2 = struct, $3 = type
my $output = "init";
my $prog = basename($0);
my @files;				# parsed files
my @init;				# sequence of [$type, $func] functions, type = init|fini
my %struct;				# list of structs found
my %struct_func;		# list of struct_init/fini functions found {struct}{type} = func

#------------------------------------------------------------------------------
# templates
#------------------------------------------------------------------------------
my $h_template = <<'END';
/* generated by [% prog %] [% files %] */

#pragma once
#define main user_main

#include "memalloc.h"   /* before any other include */

[% include_files %]

[% declare_new %]

END

my $c_template = <<'END';
/* generated by [% prog %] [% files %] */

#include "memalloc.h"   /* before any other include */

#include <stdlib.h>
#include <stdio.h>
#include <glib.h>

[% include_files %]

[% define_new %]

/* register atexit(), die on error */
static void xatexit(void (*fini)(void))
{
	if (atexit(fini) ) {
		fprintf(stderr, "atexit() failed\\n");
		exit(1);
	}
}

/* initialize all modules */
static void init()
{
	[% call_init %]
}

/* new main function to init and call user main */
extern int user_main(int argc, char *argv[]);
int main(int argc, char *argv[])
{
    init();
    return user_main(argc, argv);
}

END

my $new_template = <<'END';
struct [% struct %] * new_[% struct %](void)
{
	struct [% struct %] * self;
	
	self = g_slice_new0(struct [% struct %]);
	[% call_struct_init %]
	return self;
}

END

my $delete_template = <<'END';
void delete_[% struct %](struct [% struct %] **pself)
{
	[% call_struct_fini %]
	g_slice_free(struct [% struct %], *pself);
	*pself = NULL;
}

END

#------------------------------------------------------------------------------
# main
#------------------------------------------------------------------------------
@ARGV or die "Usage: $prog files.h\n";

for my $file (@ARGV) {
	push @files, $file;
	parse($file);
}

make_c("$output.c");
make_h("$output.h");
exit 0;

#------------------------------------------------------------------------------
# parse header files, collect information on files to generate
#------------------------------------------------------------------------------
sub parse {
	my($file) = @_;
	
	open(my $fh, $file) or die "Open $file: $!\n";
	my($func, $type, $struct);
	while (<$fh>) {
		if (($func, $type) = /$init_re/) {
			push @init, [$type, $func];
		}
		elsif (($struct) = /$struct_re/) {
			$struct{$struct}++;
		}
		elsif (($func, $struct, $type) = /$struct_func_re/) {
			$struct_func{$struct}{$type} = $func;
		}
	}
}

#------------------------------------------------------------------------------
# make init.c file
#------------------------------------------------------------------------------
sub make_c {
	my($file) = @_;
	make_output($file, $c_template);
}

#------------------------------------------------------------------------------
# make init.h file
#------------------------------------------------------------------------------
sub make_h {
	my($file) = @_;
	make_output($file, $h_template);
}

#------------------------------------------------------------------------------
# make output files
#------------------------------------------------------------------------------
sub make_output {
	my($file, $input, %vars) = @_;
	
	my $template = Template::Tiny->new( TRIM => 0 );
	
	# process call_init
	my @call_init;
	for (@init) {
		my($type, $func) = @$_;
		if ($type eq 'init') {
			push @call_init, $func."();"; 
		}
		else { 
			push @call_init, "xatexit($func);";
		}
	}
	
	# process declare_new, define_new
	my @declare_new;
	my @define_new;
	for my $struct (sort keys %struct) {
	
		my $call_struct_init = 
			exists $struct_func{$struct}{init} ? $struct_func{$struct}{init}."(self);" : "";
			
		$template->process( \$new_template,
		{
			%vars,
			struct				=> $struct,
			call_struct_init	=> $call_struct_init,
		}, \(my $new_func) );
		my($new_declare) = $new_func =~ /(.*)/;		# get first line
		
		my $call_struct_fini = 
			exists $struct_func{$struct}{fini} ? $struct_func{$struct}{fini}."(*pself);" : "";
			
		$template->process( \$delete_template,
		{
			%vars,
			struct				=> $struct,
			call_struct_fini	=> $call_struct_fini,
		}, \(my $delete_func) );
		my($delete_declare) = $delete_func =~ /(.*)/;		# get first line
		
		push @declare_new, "extern $new_declare;", "extern $delete_declare;", "";
		push @define_new, $new_func, $delete_func;
	}
	
	$template->process( \$input, 
	{ 	%vars, 
		prog 			=> $prog,
		files 			=> join(" ", @files),
		include_files 	=> join("\n", map {"#include \"$_\""} @files),
		call_init		=> join("\n    ", @call_init),
		declare_new		=> join("\n", @declare_new),
		define_new		=> join("\n", @define_new),
	}, \(my $text) );
	
	say $file;
	write_file($file, $text);
}	

__END__
# $Log: make_init.pl,v $
# Revision 1.2  2013-09-01 11:59:05  pauloscustodio
# Force memalloc to be the first include, to be able to use MSVC memory debug tools
#
# Revision 1.1  2013/09/01 00:08:55  pauloscustodio
# - Included GLIB in the Makefile options.
# - Created a code-generation mechanism for automatic execution of initialize
#   code before the main() function starts, and methods for struct malloc
#   and free calling constructors and destructors.
#
